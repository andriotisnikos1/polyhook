interface Headers extends Record<string, string> {
}
/**
 * Defines the basic operations for an HTTP client.
 */
interface HTTPClient {
    get(url: string, input: any, headers: Headers, retry?: boolean): Promise<any>;
    post(url: string, input: any, headers: Headers, retry?: boolean): Promise<any>;
    delete(url: string, input: any, headers: Headers, retry?: boolean): Promise<any>;
    put(url: string, input: any, headers: Headers, retry?: boolean): Promise<any>;
    patch(url: string, input: any, headers: Headers, retry?: boolean): Promise<any>;
}

declare class HTTPLibrary implements HTTPClient {
    readonly userAgentHeader: Headers;
    readonly retryAttempts: number;
    readonly retryDelayMs: number;
    private static readonly responseMapper;
    private readonly requestMapper;
    get(url: string, input: any, headers: Headers, retry?: boolean): Promise<any>;
    post(url: string, input: any, headers: Headers, retry?: boolean): Promise<any>;
    delete(url: string, input: any, headers: Headers, retry?: boolean): Promise<any>;
    put(url: string, input: any, headers: Headers, retry?: boolean): Promise<any>;
    patch(url: string, input: any, headers: Headers, retry?: boolean): Promise<any>;
    retry(retries: number, callbackFn: () => any, delay?: number): Promise<any>;
    private static handleResponse;
    private static httpRequest;
    private getUserAgentHeader;
    /**
     *Converts keys in an object using a provided JSON mapper.
     * @param {any} obj - The object to convert keys for.
     * @param {Object} jsonMapper - The JSON mapper containing key mappings.
     * @returns {any} - The object with converted keys.
     */
    private static convertKeysWithMapper;
}

declare class BaseService {
    baseUrl: string;
    httpClient: HTTPLibrary;
    private accessToken;
    private accessTokenPrefix;
    setAccessToken(accessToken: string): void;
    getAuthorizationHeader(): Headers;
    setBaseUrl(url: string): void;
    constructor(accessToken?: string);
    static patternMatching(value: string, pattern: string, variableName: string): string;
    static urlEncode: (input: {
        [key: string]: any;
    }) => string;
}

interface ListResponse {
    page?: number;
    projects?: {
        id?: string;
        slug?: string;
        name?: string;
        description?: string;
        created_at?: string;
    }[];
}

interface CreateResponse {
    project?: Project$2;
}
interface Project$2 {
    id?: string;
    name?: string;
    description?: string;
    created_at?: string;
}

interface CreateRequest {
    /**
     * Name of project
     */
    name: string;
    /**
     * Description of project
     */
    description?: string;
}

interface ProjectsGetResponse {
    project?: Project$1;
}
interface Project$1 {
    id?: string;
    name?: string;
    description?: string;
    created_at?: string;
}

interface ProjectsUpdateResponse {
    project?: Project;
}
interface Project {
    id?: string;
    name?: string;
    description?: string;
    created_at?: string;
}

interface ProjectsUpdateRequest {
    /**
     * Unique identifier for the project object.
     */
    project: string;
    /**
     * Name of the project.
     */
    name: string;
    /**
     * Description of the project.
     */
    description?: string;
}

interface DeleteRequest {
    /**
     * Unique identifier for the project object.
     */
    project: string;
}

declare class ProjectsService extends BaseService {
    /**
     * @summary List
     * @description Projects
  
     * @param optionalParams - Optional parameters
     * @param optionalParams.page - Page number
     * @param optionalParams.perPage - Items per page
     * @returns {Promise<ListResponse>} - The promise with the result
     */
    list(optionalParams?: {
        page?: number;
        perPage?: number;
    }): Promise<ListResponse>;
    /**
     * @summary Create
     * @description Project
  
     * @returns {Promise<CreateResponse>} - The promise with the result
     */
    create(input: CreateRequest): Promise<CreateResponse>;
    /**
     * @summary Retrieve
     * @description Project
  
     * @param project Unique identifier for the project object.
     * @returns {Promise<ProjectsGetResponse>} - The promise with the result
     */
    get(project: string): Promise<ProjectsGetResponse>;
    /**
     * @summary Update
     * @description Project
  
     * @returns {Promise<ProjectsUpdateResponse>} - The promise with the result
     */
    update(input: ProjectsUpdateRequest): Promise<ProjectsUpdateResponse>;
    /**
     * @summary Delete
     * @description Project
  
     * @returns {Promise<any>} - The promise with the result
     */
    delete(input: DeleteRequest): Promise<any>;
}

interface SecretsListResponse {
    secrets?: Secrets$2;
}
interface Secrets$2 {
    STRIPE?: Stripe$1;
    ALGOLIA?: Algolia$1;
    DATABASE?: Database$1;
    USER?: User$8;
}
interface Stripe$1 {
    raw?: string;
    computed?: string;
    note?: string;
}
interface Algolia$1 {
    raw?: string;
    computed?: string;
    note?: string;
}
interface Database$1 {
    raw?: string;
    computed?: string;
    note?: string;
}
interface User$8 {
    raw?: string;
    computed?: string;
    note?: string;
}

interface UpdateResponse {
    secrets?: Secrets$1;
}
interface Secrets$1 {
    STRIPE?: Stripe;
    ALGOLIA?: Algolia;
    DATABASE?: Database;
}
interface Stripe {
    raw?: string;
    computed?: string;
    note?: string;
}
interface Algolia {
    raw?: string;
    computed?: string;
    note?: string;
}
interface Database {
    raw?: string;
    computed?: string;
    note?: string;
}

interface UpdateRequest {
    /**
     * Unique identifier for the project object.
     */
    project: string;
    /**
     * Name of the config object.
     */
    config: string;
    secrets: Secrets;
}
/**
 * Object of secrets you would like to save to the config. Try it with the sample secrets below:
 */
interface Secrets {
    STRIPE: string;
    ALGOLIA?: string;
    DATABASE?: string;
}

interface SecretsGetResponse {
    name?: string;
    value?: Value$1;
}
interface Value$1 {
    raw?: string;
    computed?: string;
    note?: string;
}

declare type Format = 'json' | 'dotnet-json' | 'env' | 'yaml' | 'docker' | 'env-no-quotes';

declare type NameTransformer = 'camel' | 'upper-camel' | 'lower-snake' | 'tf-var' | 'dotnet' | 'dotnet-env' | 'lower-kebab';

interface DownloadResponse {
    STRIPE?: string;
    ALGOLIA?: string;
    DATABASE?: string;
    USER?: string;
}

interface NamesResponse {
    names?: string[];
}

interface UpdateNoteResponse {
    secret?: string;
    note?: string;
}

interface UpdateNoteRequest {
    /**
     * Unique identifier for the project object.
     */
    project: string;
    /**
     * Name of the config object.
     */
    config: string;
    secret: string;
    note: string;
}

declare class SecretsService extends BaseService {
    /**
     * @summary List
     * @description Secrets
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @param optionalParams - Optional parameters
     * @param optionalParams.accepts - Available options are: **application/json**, **text/plain**
     * @param optionalParams.includeDynamicSecrets - Whether or not to issue leases and include dynamic secret values for the config
     * @param optionalParams.dynamicSecretsTtlSec - The number of seconds until dynamic leases expire. Must be used with `include_dynamic_secrets`. Defaults to 1800 (30 minutes).
     * @param optionalParams.secrets - A comma-separated list of secrets to include in the response
     * @param optionalParams.includeManagedSecrets - Whether to include Doppler's auto-generated (managed) secrets
     * @returns {Promise<SecretsListResponse>} - The promise with the result
     */
    list(project: string, config: string, optionalParams?: {
        accepts?: string;
        includeDynamicSecrets?: boolean;
        dynamicSecretsTtlSec?: number;
        secrets?: string;
        includeManagedSecrets?: boolean;
    }): Promise<SecretsListResponse>;
    /**
     * @summary Update
     * @description Secrets
  
     * @returns {Promise<UpdateResponse>} - The promise with the result
     */
    update(input: UpdateRequest): Promise<UpdateResponse>;
    /**
     * @summary Retrieve
     * @description Secret
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @param name Name of the secret.
     * @returns {Promise<SecretsGetResponse>} - The promise with the result
     */
    get(project: string, config: string, name: string): Promise<SecretsGetResponse>;
    /**
     * @summary Delete
     * @description Secret
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @param name Name of the secret.
     * @returns {Promise<any>} - The promise with the result
     */
    delete(project: string, config: string, name: string): Promise<any>;
    /**
     * @summary Download
     * @description Download Secrets
  
     * @param project Unique identifier for the project object. Not required if using a Service Token.
     * @param config Name of the config object. Not required if using a Service Token.
     * @param optionalParams - Optional parameters
     * @param optionalParams.format - Needed input variable
     * @param optionalParams.nameTransformer - Transform secret names to a different case
     * @param optionalParams.includeDynamicSecrets - Whether or not to issue leases and include dynamic secret values for the config
     * @param optionalParams.dynamicSecretsTtlSec - The number of seconds until dynamic leases expire. Must be used with `include_dynamic_secrets`. Defaults to 1800 (30 minutes).
     * @returns {Promise<DownloadResponse>} - The promise with the result
     */
    download(project: string, config: string, optionalParams?: {
        format?: Format;
        nameTransformer?: NameTransformer;
        includeDynamicSecrets?: boolean;
        dynamicSecretsTtlSec?: number;
    }): Promise<DownloadResponse>;
    /**
     * @summary List Names
     * @description Secret Names
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @param optionalParams - Optional parameters
     * @param optionalParams.includeDynamicSecrets - Whether or not to issue leases and include dynamic secret values for the config
     * @param optionalParams.includeManagedSecrets - Whether to include Doppler's auto-generated (managed) secrets
     * @returns {Promise<NamesResponse>} - The promise with the result
     */
    names(project: string, config: string, optionalParams?: {
        includeDynamicSecrets?: boolean;
        includeManagedSecrets?: boolean;
    }): Promise<NamesResponse>;
    /**
     * @summary Update Note
     * @description Set a note on a secret
  
     * @returns {Promise<UpdateNoteResponse>} - The promise with the result
     */
    updateNote(input: UpdateNoteRequest): Promise<UpdateNoteResponse>;
}

interface ConfigLogsListResponse {
    page?: number;
    logs?: {
        id?: string;
        text?: string;
        html?: string;
        rollback?: boolean;
        created_at?: string;
        config?: string;
        environment?: string;
        project?: string;
        user?: User$7;
    }[];
}
interface User$7 {
    email?: string;
    name?: string;
    username?: string;
    profile_image_url?: string;
}

interface GetResponse {
    log?: Log$2;
}
interface Log$2 {
    id?: string;
    text?: string;
    html?: string;
    diff?: {
        name?: string;
        added?: string;
    }[];
    rollback?: boolean;
    created_at?: string;
    config?: string;
    environment?: string;
    project?: string;
    user?: User$6;
}
interface User$6 {
    email?: string;
    name?: string;
    username?: string;
    profile_image_url?: string;
}

interface RollbackResponse {
    log?: Log$1;
}
interface Log$1 {
    id?: string;
    text?: string;
    html?: string;
    diff?: {
        name?: string;
        removed?: string;
    }[];
    rollback?: boolean;
    created_at?: string;
    config?: string;
    environment?: string;
    project?: string;
    user?: User$5;
}
interface User$5 {
    email?: string;
    name?: string;
    username?: string;
    profile_image_url?: string;
}

declare class ConfigLogsService extends BaseService {
    /**
     * @summary List
     * @description Config Logs
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @param optionalParams - Optional parameters
     * @param optionalParams.page - Page number
     * @param optionalParams.perPage - Items per page
     * @returns {Promise<ConfigLogsListResponse>} - The promise with the result
     */
    list(project: string, config: string, optionalParams?: {
        page?: number;
        perPage?: number;
    }): Promise<ConfigLogsListResponse>;
    /**
     * @summary Retrieve
     * @description Config Log
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @param log Unique identifier for the log object.
     * @returns {Promise<GetResponse>} - The promise with the result
     */
    get(project: string, config: string, log: string): Promise<GetResponse>;
    /**
     * @summary Rollback
     * @description Config Log
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @param log Unique identifier for the log object.
     * @returns {Promise<RollbackResponse>} - The promise with the result
     */
    rollback(project: string, config: string, log: string): Promise<RollbackResponse>;
}

interface EnvironmentsGetResponse {
    environment?: Environment$2;
}
interface Environment$2 {
    id?: string;
    name?: string;
    initial_fetch_at?: string;
    created_at?: string;
    project?: string;
}

interface RenameResponse {
    environment?: Environment$1;
}
interface Environment$1 {
    id?: string;
    name?: string;
    initial_fetch_at?: string;
    created_at?: string;
    project?: string;
}

interface RenameRequest {
    /**
     * Desired name
     */
    name?: string;
    /**
     * Desired slug
     */
    slug?: string;
}

interface EnvironmentsListResponse {
    environments?: {
        id?: string;
        name?: string;
        initial_fetch_at?: string;
        created_at?: string;
        project?: string;
    }[];
    page?: number;
}

interface EnvironmentsCreateResponse {
    environment?: Environment;
}
interface Environment {
    id?: string;
    name?: string;
    initial_fetch_at?: string;
    created_at?: string;
    project?: string;
}

interface EnvironmentsCreateRequest {
    name: string;
    slug: string;
}

declare class EnvironmentsService extends BaseService {
    /**
     * @summary Retrieve
     * @description Environment
  
     * @param project The project's name
     * @param environment The environment's slug
     * @returns {Promise<EnvironmentsGetResponse>} - The promise with the result
     */
    get(project: string, environment: string): Promise<EnvironmentsGetResponse>;
    /**
     * @summary Rename
     * @description Environment
  
     * @param project The project's name
     * @param environment The environment's slug
     * @returns {Promise<RenameResponse>} - The promise with the result
     */
    rename(input: RenameRequest, project: string, environment: string): Promise<RenameResponse>;
    /**
     * @summary Delete
     * @description Environment
  
     * @param project The project's name
     * @param environment The environment's slug
     * @returns {Promise<any>} - The promise with the result
     */
    delete(project: string, environment: string): Promise<any>;
    /**
     * @summary List
     * @description Environments
  
     * @param project The project's name
     * @returns {Promise<EnvironmentsListResponse>} - The promise with the result
     */
    list(project: string): Promise<EnvironmentsListResponse>;
    /**
     * @summary Create
     * @description Environment
  
     * @param project The project's name
     * @returns {Promise<EnvironmentsCreateResponse>} - The promise with the result
     */
    create(input: EnvironmentsCreateRequest, project: string): Promise<EnvironmentsCreateResponse>;
}

interface ConfigsListResponse {
    page?: number;
    configs?: {
        name?: string;
        root?: boolean;
        locked?: boolean;
        initial_fetch_at?: string;
        last_fetch_at?: string;
        created_at?: string;
        environment?: string;
        project?: string;
    }[];
}

interface ConfigsCreateResponse {
    config?: Config$8;
}
interface Config$8 {
    name?: string;
    root?: boolean;
    locked?: boolean;
    initial_fetch_at?: string;
    last_fetch_at?: string;
    created_at?: string;
    environment?: string;
    project?: string;
}

interface ConfigsCreateRequest {
    /**
     * Unique identifier for the project object.
     */
    project: string;
    /**
     * Identifier for the environment object.
     */
    environment: string;
    /**
     * Name of the new branch config.
     */
    name: string;
}

interface ConfigsGetResponse {
    config?: Config$7;
}
interface Config$7 {
    name?: string;
    root?: boolean;
    locked?: boolean;
    initial_fetch_at?: string;
    last_fetch_at?: string;
    created_at?: string;
    environment?: string;
    project?: string;
}

interface ConfigsUpdateResponse {
    config?: Config$6;
}
interface Config$6 {
    name?: string;
    root?: boolean;
    locked?: boolean;
    initial_fetch_at?: string;
    last_fetch_at?: string;
    created_at?: string;
    environment?: string;
    project?: string;
}

interface DeleteResponse {
    success?: boolean;
}

interface ConfigsUpdateRequest {
    /**
     * Unique identifier for the project object.
     */
    project: string;
    /**
     * Name of the config object.
     */
    config: string;
    /**
     * The new name of config.
     */
    name: string;
}

interface ConfigsDeleteRequest {
    /**
     * Unique identifier for the project object.
     */
    project: string;
    /**
     * Name of the config object.
     */
    config: string;
}

interface CloneResponse {
    config?: Config$5;
}
interface Config$5 {
    name?: string;
    root?: boolean;
    locked?: boolean;
    initial_fetch_at?: string;
    last_fetch_at?: string;
    created_at?: string;
    environment?: string;
    project?: string;
}

interface CloneRequest {
    /**
     * Unique identifier for the project object.
     */
    project: string;
    /**
     * Name of the branch config being cloned.
     */
    config: string;
    /**
     * Name of the new branch config.
     */
    name: string;
}

interface LockResponse {
    config?: Config$4;
}
interface Config$4 {
    name?: string;
    root?: boolean;
    locked?: boolean;
    initial_fetch_at?: string;
    last_fetch_at?: string;
    created_at?: string;
    environment?: string;
    project?: string;
}

interface LockRequest {
    /**
     * Unique identifier for the project object.
     */
    project: string;
    /**
     * Name of the config.
     */
    config: string;
}

interface UnlockResponse {
    config?: Config$3;
}
interface Config$3 {
    name?: string;
    root?: boolean;
    locked?: boolean;
    initial_fetch_at?: string;
    last_fetch_at?: string;
    created_at?: string;
    environment?: string;
    project?: string;
}

interface UnlockRequest {
    /**
     * Unique identifier for the project object.
     */
    project: string;
    /**
     * Name of the config.
     */
    config: string;
}

interface ListTrustedIpsResponse {
    ips?: string[];
}

interface AddTrustedIpResponse {
    ip?: string;
}

interface AddTrustedIpRequest {
    /**
     * An IP address or CIDR range
     */
    ip: string;
}

interface DeleteTrustedIpRequest {
    /**
     * An IP address or CIDR range
     */
    ip: string;
}

declare class ConfigsService extends BaseService {
    /**
     * @summary List
     * @description Fetch all configs.
  
     * @param project The project's name
     * @param optionalParams - Optional parameters
     * @param optionalParams.environment - (optional) the environment from which to list configs
     * @param optionalParams.page - Page number
     * @param optionalParams.perPage - Items per page
     * @returns {Promise<ConfigsListResponse>} - The promise with the result
     */
    list(project: string, optionalParams?: {
        environment?: string;
        page?: number;
        perPage?: number;
    }): Promise<ConfigsListResponse>;
    /**
     * @summary Create
     * @description Create a new branch config.
  
     * @returns {Promise<ConfigsCreateResponse>} - The promise with the result
     */
    create(input: ConfigsCreateRequest): Promise<ConfigsCreateResponse>;
    /**
     * @summary Retrieve
     * @description Fetch a config's details.
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @returns {Promise<ConfigsGetResponse>} - The promise with the result
     */
    get(project: string, config: string): Promise<ConfigsGetResponse>;
    /**
     * @summary Update
     * @description Modify an existing config.
  
     * @returns {Promise<ConfigsUpdateResponse>} - The promise with the result
     */
    update(input: ConfigsUpdateRequest): Promise<ConfigsUpdateResponse>;
    /**
     * @summary Delete
     * @description Permanently delete the config.
  
     * @returns {Promise<DeleteResponse>} - The promise with the result
     */
    delete(input: ConfigsDeleteRequest): Promise<DeleteResponse>;
    /**
     * @summary Clone
     * @description Create a new branch config by cloning another. This duplicates a branch config and all its secrets.
  
     * @returns {Promise<CloneResponse>} - The promise with the result
     */
    clone(input: CloneRequest): Promise<CloneResponse>;
    /**
     * @summary Lock
     * @description Prevent the config from being renamed or deleted.
  
     * @returns {Promise<LockResponse>} - The promise with the result
     */
    lock(input: LockRequest): Promise<LockResponse>;
    /**
     * @summary Unlock
     * @description Allow the config to be renamed and/or deleted.
  
     * @returns {Promise<UnlockResponse>} - The promise with the result
     */
    unlock(input: UnlockRequest): Promise<UnlockResponse>;
    /**
     * @summary List
  
     * @param project Needed input variable
     * @param config Needed input variable
     * @returns {Promise<ListTrustedIpsResponse>} - The promise with the result
     */
    listTrustedIps(project: string, config: string): Promise<ListTrustedIpsResponse>;
    /**
     * @summary Add
  
     * @param project Needed input variable
     * @param config Needed input variable
     * @returns {Promise<AddTrustedIpResponse>} - The promise with the result
     */
    addTrustedIp(input: AddTrustedIpRequest, project: string, config: string): Promise<AddTrustedIpResponse>;
    /**
     * @summary Delete
  
     * @param project Needed input variable
     * @param config Needed input variable
     * @returns {Promise<any>} - The promise with the result
     */
    deleteTrustedIp(input: DeleteTrustedIpRequest, project: string, config: string): Promise<any>;
}

interface RetrieveResponse {
    log?: Log;
}
interface Log {
    id?: string;
    text?: string;
    html?: string;
    created_at?: string;
    config?: Config$2;
    environment?: string;
    project?: string;
    user?: User$4;
}
interface Config$2 {
    [k: string]: unknown;
}
interface User$4 {
    email?: string;
    name?: string;
    profile_image_url?: string;
}

interface ActivityLogsListResponse {
    page?: number;
    logs?: {
        id?: string;
        text?: string;
        html?: string;
        created_at?: string;
        config?: Config$1;
        environment?: string;
        project?: string;
        user?: User$3;
    }[];
}
interface Config$1 {
    [k: string]: unknown;
}
interface User$3 {
    email?: string;
    name?: string;
    profile_image_url?: string;
}

declare class ActivityLogsService extends BaseService {
    /**
     * @summary Retrieve
     * @description Activity Log
  
     * @param log Unique identifier for the log object.
     * @returns {Promise<RetrieveResponse>} - The promise with the result
     */
    retrieve(log: string): Promise<RetrieveResponse>;
    /**
     * @summary List
     * @description Activity Logs
  
     * @param optionalParams - Optional parameters
     * @param optionalParams.page - Page number
     * @param optionalParams.perPage - Items per page
     * @returns {Promise<ActivityLogsListResponse>} - The promise with the result
     */
    list(optionalParams?: {
        page?: string;
        perPage?: number;
    }): Promise<ActivityLogsListResponse>;
}

interface WorkplaceGetResponse {
    workplace?: Workplace$2;
}
interface Workplace$2 {
    id?: string;
    name?: string;
    billing_email?: string;
    security_email?: string;
}

interface WorkplaceUpdateResponse {
    workplace?: Workplace$1;
}
interface Workplace$1 {
    id?: string;
    name?: string;
    billing_email?: string;
    security_email?: string;
}

interface WorkplaceUpdateRequest {
    /**
     * Workplace name
     */
    name?: string;
    billing_email?: string;
    security_email?: string;
}

declare class WorkplaceService extends BaseService {
    /**
     * @summary Retrieve
  
     * @returns {Promise<WorkplaceGetResponse>} - The promise with the result
     */
    get(): Promise<WorkplaceGetResponse>;
    /**
     * @summary Update
  
     * @returns {Promise<WorkplaceUpdateResponse>} - The promise with the result
     */
    update(input: WorkplaceUpdateRequest): Promise<WorkplaceUpdateResponse>;
}

interface ServiceTokensListResponse {
    tokens?: {
        name?: string;
        slug?: string;
        created_at?: string;
        config?: string;
        environment?: string;
        project?: string;
        expires_at?: ExpiresAt$1;
    }[];
}
interface ExpiresAt$1 {
    [k: string]: unknown;
}

interface ServiceTokensCreateResponse {
    name?: string;
    slug?: string;
    created_at?: string;
    key?: string;
    config?: string;
    environment?: string;
    project?: string;
    expires_at?: ExpiresAt;
    access?: string;
}
interface ExpiresAt {
    [k: string]: unknown;
}

/**
 * Token's capabilities.
 */
declare type Access = 'read' | 'read/write';
interface ServiceTokensCreateRequest {
    /**
     * Unique identifier for the project object.
     */
    project: string;
    /**
     * Name of the config object.
     */
    config: string;
    /**
     * Name of the service token.
     */
    name: string;
    /**
     * Unix timestamp of when token should expire.
     */
    expire_at?: string;
    access?: Access;
}

interface ServiceTokensDeleteRequest {
    /**
     * Unique identifier for the project object.
     */
    project: string;
    /**
     * Name of the config object.
     */
    config: string;
    /**
     * The slug of the service token.
     */
    slug?: string;
    /**
     * The token value.
     */
    token?: string;
}

declare class ServiceTokensService extends BaseService {
    /**
     * @summary List
     * @description Service Tokens
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @returns {Promise<ServiceTokensListResponse>} - The promise with the result
     */
    list(project: string, config: string): Promise<ServiceTokensListResponse>;
    /**
     * @summary Create
     * @description Service Token
  
     * @returns {Promise<ServiceTokensCreateResponse>} - The promise with the result
     */
    create(input: ServiceTokensCreateRequest): Promise<ServiceTokensCreateResponse>;
    /**
     * @summary Delete
     * @description Service Token
  
     * @returns {Promise<DeleteResponse>} - The promise with the result
     */
    delete(input: ServiceTokensDeleteRequest): Promise<DeleteResponse>;
}

interface GetUserResponse {
    workplace_user?: WorkplaceUser$1;
    success?: boolean;
}
interface WorkplaceUser$1 {
    id?: string;
    access?: string;
    created_at?: string;
    user?: User$2;
}
interface User$2 {
    email?: string;
    name?: string;
    username?: string;
    profile_image_url?: string;
    mfa_enabled?: boolean;
    thirdparty_sso_enabled?: boolean;
    saml_sso_enabled?: boolean;
}

declare class AuditService extends BaseService {
    /**
     * @summary Workplace User
     * @description Get a specific user in a workplace
  
     * @param workplaceUserId The ID of the workplace user
     * @param optionalParams - Optional parameters
     * @param optionalParams.settings - If true, the api will return more information if the user has e.g. SAML enabled and/or Multi Factor Auth enabled
     * @returns {Promise<GetUserResponse>} - The promise with the result
     */
    getUser(workplaceUserId: string, optionalParams?: {
        settings?: boolean;
    }): Promise<GetUserResponse>;
}

interface IssueLeaseResponse {
    success?: boolean;
    id?: string;
    expires_at?: string;
    value?: Value;
}
interface Value {
}

interface IssueLeaseRequest {
    /**
     * The project where the dynamic secret is located
     */
    project: string;
    /**
     * The config where the dynamic secret is located
     */
    config: string;
    /**
     * The name of the dynamic secret for which to issue this lease
     */
    dynamic_secret: string;
    /**
     * The number of seconds until this lease is automatically revoked
     */
    ttl_sec: number;
}

interface RevokeLeaseResponse {
    success?: boolean;
}

interface RevokeLeaseRequest {
    /**
     * The project where the dynamic secret is located
     */
    project: string;
    /**
     * The config where the dynamic secret is located
     */
    config: string;
    /**
     * The name of the dynamic secret from which this lease was issued
     */
    dynamic_secret: string;
    /**
     * The slug of the lease to revoke
     */
    slug: string;
}

declare class DynamicSecretsService extends BaseService {
    /**
     * @summary Issue Lease
     * @description Issue a lease for a dynamic secret
  
     * @returns {Promise<IssueLeaseResponse>} - The promise with the result
     */
    issueLease(input: IssueLeaseRequest): Promise<IssueLeaseResponse>;
    /**
     * @summary Revoke Lease
  
     * @returns {Promise<RevokeLeaseResponse>} - The promise with the result
     */
    revokeLease(input: RevokeLeaseRequest): Promise<RevokeLeaseResponse>;
}

interface RevokeRequest {
    token: string;
}

interface MeResponse {
    slug?: string;
    name?: string;
    created_at?: string;
    last_seen_at?: string;
    token_preview?: string;
    workplace?: Workplace;
    type_?: string;
}
interface Workplace {
    slug?: string;
    name?: string;
}

declare class AuthService extends BaseService {
    /**
     * @summary Revoke
     * @description Revoke an auth token
  
     * @returns {Promise<any>} - The promise with the result
     */
    revoke(input: RevokeRequest): Promise<any>;
    /**
     * @summary Me
     * @description Get information about a token
  
     * @returns {Promise<MeResponse>} - The promise with the result
     */
    me(): Promise<MeResponse>;
}

interface IntegrationsListResponse {
    integrations?: {
        slug?: string;
        name?: string;
        kind?: string;
        enabled?: boolean;
        type_?: string;
    }[];
    success?: boolean;
}

interface IntegrationsCreateResponse {
    integration?: Integration$1;
}
interface Integration$1 {
    slug?: string;
    name?: string;
    type_?: string;
}

interface IntegrationsCreateRequest {
    /**
     * The name of the integration
     */
    name: string;
    data?: Data$1;
    /**
     * The integration type
     */
    type_: string;
}
/**
 * The authentication data for the integration
 */
interface Data$1 {
}

interface IntegrationsGetResponse {
    integration?: Integration;
}
interface Integration {
    slug?: string;
    name?: string;
    type_?: string;
}

interface IntegrationsUpdateResponse {
}

interface IntegrationsDeleteResponse {
}

interface IntegrationsUpdateRequest {
    /**
     * The new name of the integration
     */
    name?: string;
    /**
     * The new authentication data for the integration
     */
    data?: string;
}

declare class IntegrationsService extends BaseService {
    /**
     * @summary List
     * @description List all existing integrations
  
     * @returns {Promise<IntegrationsListResponse>} - The promise with the result
     */
    list(): Promise<IntegrationsListResponse>;
    /**
     * @summary Create
     * @description Create a new external integration.
  
     * @returns {Promise<IntegrationsCreateResponse>} - The promise with the result
     */
    create(input: IntegrationsCreateRequest): Promise<IntegrationsCreateResponse>;
    /**
     * @summary Retrieve
     * @description Retrieve an existing integration
  
     * @param integration The integration slug
     * @returns {Promise<IntegrationsGetResponse>} - The promise with the result
     */
    get(integration: string): Promise<IntegrationsGetResponse>;
    /**
     * @summary Update
     * @description Update an existing integration.
  
     * @param integration The slug of the integration to update
     * @returns {Promise<IntegrationsUpdateResponse>} - The promise with the result
     */
    update(input: IntegrationsUpdateRequest, integration: string): Promise<IntegrationsUpdateResponse>;
    /**
     * @summary Delete
     * @description Delete an existing integration.
  
     * @param integration The slug of the integration to delete
     * @returns {Promise<IntegrationsDeleteResponse>} - The promise with the result
     */
    delete(integration: string): Promise<IntegrationsDeleteResponse>;
}

interface SyncsCreateResponse {
    sync?: Sync$1;
}
interface Sync$1 {
    slug?: string;
    integration?: string;
    project?: string;
    config?: string;
    enabled?: boolean;
    lastSyncedAt?: string;
}

/**
 * An option indicating if and how Doppler should attempt to import secrets from the sync destination
 */
declare type ImportOption = 'none' | 'prefer_doppler' | 'prefer_integration';
interface SyncsCreateRequest {
    /**
     * The integration slug which the sync will use
     */
    integration: string;
    data: Data;
    import_option?: ImportOption;
}
/**
 * Configuration data for the sync
 */
interface Data {
}

interface SyncsGetResponse {
    sync?: Sync;
}
interface Sync {
    slug?: string;
    integration?: string;
    project?: string;
    config?: string;
    enabled?: boolean;
    lastSyncedAt?: string;
}

interface SyncsDeleteResponse {
}

declare class SyncsService extends BaseService {
    /**
     * @summary Create
     * @description Create a new secrets sync.
  
     * @param project The project slug
     * @param config The config slug
     * @returns {Promise<SyncsCreateResponse>} - The promise with the result
     */
    create(input: SyncsCreateRequest, project: string, config: string): Promise<SyncsCreateResponse>;
    /**
     * @summary Retrieve
     * @description Retrieve an existing secrets sync.
  
     * @param project The project slug
     * @param config The config slug
     * @param sync The sync slug
     * @returns {Promise<SyncsGetResponse>} - The promise with the result
     */
    get(project: string, config: string, sync: string): Promise<SyncsGetResponse>;
    /**
     * @summary Delete
     * @description Delete an existing sync.
  
     * @param project The project slug
     * @param config The config slug
     * @param sync The sync slug
     * @param deleteFromTarget Whether or not to delete the synced data from the target integration
     * @returns {Promise<SyncsDeleteResponse>} - The promise with the result
     */
    delete(project: string, config: string, sync: string, deleteFromTarget: boolean): Promise<SyncsDeleteResponse>;
}

interface WorkplaceRolesListResponse {
    roles?: {
        name?: string;
        permissions?: string[];
        identifier?: string;
        created_at?: string;
        is_custom_role?: boolean;
        is_inline_role?: boolean;
    }[];
}

interface WorkplaceRolesCreateResponse {
    role?: Role$c;
}
interface Role$c {
    name?: string;
    permissions?: string[];
    identifier?: string;
    created_at?: string;
    is_custom_role?: boolean;
    is_inline_role?: boolean;
}

interface ListPermissionsResponse {
    permissions?: string[];
}

interface WorkplaceRolesGetResponse {
    role?: Role$b;
}
interface Role$b {
    name?: string;
    permissions?: string[];
    identifier?: string;
    created_at?: string;
    is_custom_role?: boolean;
    is_inline_role?: boolean;
}

interface WorkplaceRolesUpdateResponse {
    role?: Role$a;
}
interface Role$a {
    name?: string;
    permissions?: string[];
    identifier?: string;
    created_at?: string;
    is_custom_role?: boolean;
    is_inline_role?: boolean;
}

declare class WorkplaceRolesService extends BaseService {
    /**
     * @summary List
  
     * @returns {Promise<WorkplaceRolesListResponse>} - The promise with the result
     */
    list(): Promise<WorkplaceRolesListResponse>;
    /**
     * @summary Create
  
     * @returns {Promise<WorkplaceRolesCreateResponse>} - The promise with the result
     */
    create(): Promise<WorkplaceRolesCreateResponse>;
    /**
     * @summary List Permissions
  
     * @returns {Promise<ListPermissionsResponse>} - The promise with the result
     */
    listPermissions(): Promise<ListPermissionsResponse>;
    /**
     * @summary Retrieve
  
     * @param role The role's unique identifier
     * @returns {Promise<WorkplaceRolesGetResponse>} - The promise with the result
     */
    get(role: string): Promise<WorkplaceRolesGetResponse>;
    /**
     * @summary Update
  
     * @param role The role's unique identifier
     * @returns {Promise<WorkplaceRolesUpdateResponse>} - The promise with the result
     */
    update(role: string): Promise<WorkplaceRolesUpdateResponse>;
    /**
     * @summary Delete
  
     * @param role The role's unique identifier
     * @returns {Promise<any>} - The promise with the result
     */
    delete(role: string): Promise<any>;
}

interface ProjectRolesListResponse {
    roles?: {
        name?: string;
        permissions?: string[];
        identifier?: string;
        created_at?: string;
        is_custom_role?: boolean;
    }[];
}

interface ProjectRolesCreateResponse {
    role?: Role$9;
}
interface Role$9 {
    name?: string;
    permissions?: string[];
    identifier?: string;
    created_at?: string;
    is_custom_role?: boolean;
}

interface ProjectRolesGetResponse {
    role?: Role$8;
}
interface Role$8 {
    name?: string;
    permissions?: string[];
    identifier?: string;
    created_at?: string;
    is_custom_role?: boolean;
}

interface ProjectRolesUpdateResponse {
    role?: Role$7;
}
interface Role$7 {
    name?: string;
    permissions?: string[];
    identifier?: string;
    created_at?: string;
    is_custom_role?: boolean;
}

interface ProjectRolesListPermissionsResponse {
    permissions?: string[];
}

declare class ProjectRolesService extends BaseService {
    /**
     * @summary List
  
     * @returns {Promise<ProjectRolesListResponse>} - The promise with the result
     */
    list(): Promise<ProjectRolesListResponse>;
    /**
     * @summary Create
  
     * @returns {Promise<ProjectRolesCreateResponse>} - The promise with the result
     */
    create(): Promise<ProjectRolesCreateResponse>;
    /**
     * @summary Retrieve
  
     * @param role The role's unique identifier
     * @returns {Promise<ProjectRolesGetResponse>} - The promise with the result
     */
    get(role: string): Promise<ProjectRolesGetResponse>;
    /**
     * @summary Update
  
     * @param role The role's unique identifier
     * @returns {Promise<ProjectRolesUpdateResponse>} - The promise with the result
     */
    update(role: string): Promise<ProjectRolesUpdateResponse>;
    /**
     * @summary Delete
  
     * @param role The role's unique identifier
     * @returns {Promise<any>} - The promise with the result
     */
    delete(role: string): Promise<any>;
    /**
     * @summary List Permissions
  
     * @returns {Promise<ProjectRolesListPermissionsResponse>} - The promise with the result
     */
    listPermissions(): Promise<ProjectRolesListPermissionsResponse>;
}

interface ProjectMembersListResponse {
    members?: {
        slug?: string;
        role?: Role$6;
        access_all_environments?: boolean;
        environments?: string[];
        type_?: string;
    }[];
}
interface Role$6 {
    identifier?: string;
}

interface AddResponse {
    member?: Member$2;
}
interface Member$2 {
    slug?: string;
    role?: Role$5;
    access_all_environments?: boolean;
    environments?: string[];
    type_?: string;
}
interface Role$5 {
    identifier?: string;
}

declare type Type$2 = 'workplace_user' | 'group' | 'invite' | 'service_account';
interface AddRequest {
    /**
     * Member's slug
     */
    slug: string;
    /**
     * Identifier of the project role
     */
    role?: string;
    /**
     * Environment slugs to grant the member access to
     */
    environments?: string[];
    type_: Type$2;
}

declare type Type$1 = 'workplace_user' | 'group' | 'invite' | 'service_account';

interface ProjectMembersGetResponse {
    member?: Member$1;
}
interface Member$1 {
    slug?: string;
    role?: Role$4;
    access_all_environments?: boolean;
    environments?: string[];
    type_?: string;
}
interface Role$4 {
    identifier?: string;
}

interface ProjectMembersUpdateResponse {
    member?: Member;
}
interface Member {
    slug?: string;
    role?: Role$3;
    access_all_environments?: boolean;
    environments?: string[];
    type_?: string;
}
interface Role$3 {
    identifier?: string;
}

interface ProjectMembersUpdateRequest {
    /**
     * Identifier of the project role
     */
    role?: string;
    /**
     * Environment slugs to grant the member access to
     */
    environments?: string[];
}

declare class ProjectMembersService extends BaseService {
    /**
     * @summary List
  
     * @param project Project slug
     * @param optionalParams - Optional parameters
     * @param optionalParams.page - Needed input variable
     * @param optionalParams.perPage - Needed input variable
     * @returns {Promise<ProjectMembersListResponse>} - The promise with the result
     */
    list(project: string, optionalParams?: {
        page?: number;
        perPage?: number;
    }): Promise<ProjectMembersListResponse>;
    /**
     * @summary Add
  
     * @param project Project slug
     * @returns {Promise<AddResponse>} - The promise with the result
     */
    add(input: AddRequest, project: string): Promise<AddResponse>;
    /**
     * @summary Retrieve
  
     * @param project Project slug
     * @param type_ Needed input variable
     * @param slug Member's slug
     * @returns {Promise<ProjectMembersGetResponse>} - The promise with the result
     */
    get(project: string, type: Type$1, slug: string): Promise<ProjectMembersGetResponse>;
    /**
     * @summary Update
  
     * @param type_ Needed input variable
     * @param slug Member's slug
     * @param project Project slug
     * @returns {Promise<ProjectMembersUpdateResponse>} - The promise with the result
     */
    update(input: ProjectMembersUpdateRequest, type: Type$1, slug: string, project: string): Promise<ProjectMembersUpdateResponse>;
    /**
     * @summary Delete
  
     * @param type_ Needed input variable
     * @param slug Member's slug
     * @param project Project slug
     * @returns {Promise<any>} - The promise with the result
     */
    delete(type: Type$1, slug: string, project: string): Promise<any>;
}

interface InvitesListResponse {
    invites?: {
        slug?: string;
        email?: string;
        created_at?: string;
        workplace_role?: WorkplaceRole$6;
    }[];
}
interface WorkplaceRole$6 {
    name?: string;
    permissions?: string[];
    identifier?: string;
    created_at?: string;
    is_custom_role?: boolean;
    is_inline_role?: boolean;
}

declare class InvitesService extends BaseService {
    /**
     * @summary List
  
     * @param optionalParams - Optional parameters
     * @param optionalParams.page - Needed input variable
     * @param optionalParams.perPage - Needed input variable
     * @returns {Promise<InvitesListResponse>} - The promise with the result
     */
    list(optionalParams?: {
        page?: number;
        perPage?: number;
    }): Promise<InvitesListResponse>;
}

interface ServiceAccountsListResponse {
    service_accounts?: {
        name?: string;
        slug?: string;
        created_at?: string;
        workplace_role?: WorkplaceRole$5;
    }[];
}
interface WorkplaceRole$5 {
    name?: string;
    permissions?: string[];
    identifier?: string;
    created_at?: string;
    is_custom_role?: boolean;
    is_inline_role?: boolean;
}

interface ServiceAccountsCreateResponse {
    service_account?: ServiceAccount$2;
}
interface ServiceAccount$2 {
    name?: string;
    slug?: string;
    created_at?: string;
    workplace_role?: WorkplaceRole$4;
}
interface WorkplaceRole$4 {
    name?: string;
    permissions?: string[];
    identifier?: string;
    created_at?: string;
    is_custom_role?: boolean;
    is_inline_role?: boolean;
}

interface ServiceAccountsCreateRequest {
    name?: string;
    workplace_role?: WorkplaceRole$3;
}
/**
 * You may provide an identifier OR permissions, but not both
 */
interface WorkplaceRole$3 {
    /**
     * Identifier of an existing workplace role
     */
    identifier?: string;
    /**
     * Workplace permissions to grant
     */
    permissions?: string[];
}

interface ServiceAccountsGetResponse {
    service_account?: ServiceAccount$1;
}
interface ServiceAccount$1 {
    name?: string;
    slug?: string;
    created_at?: string;
    workplace_role?: WorkplaceRole$2;
}
interface WorkplaceRole$2 {
    name?: string;
    permissions?: string[];
    identifier?: string;
    created_at?: string;
    is_custom_role?: boolean;
    is_inline_role?: boolean;
}

declare type Permissions = unknown[];
interface ServiceAccountsUpdateResponse {
    service_account?: ServiceAccount;
}
interface ServiceAccount {
    name?: string;
    slug?: string;
    created_at?: string;
    workplace_role?: WorkplaceRole$1;
}
interface WorkplaceRole$1 {
    name?: string;
    permissions?: Permissions;
    identifier?: string;
    created_at?: string;
    is_custom_role?: boolean;
    is_inline_role?: boolean;
}

interface ServiceAccountsUpdateRequest {
    name?: string;
    workplace_role?: WorkplaceRole;
}
/**
 * You may provide an identifier OR permissions, but not both
 */
interface WorkplaceRole {
    /**
     * Identifier of an existing workplace role
     */
    identifier?: string;
    /**
     * Workplace permissions to grant
     */
    permissions?: string[];
}

declare class ServiceAccountsService extends BaseService {
    /**
     * @summary List
  
     * @param optionalParams - Optional parameters
     * @param optionalParams.page - Needed input variable
     * @param optionalParams.perPage - Needed input variable
     * @returns {Promise<ServiceAccountsListResponse>} - The promise with the result
     */
    list(optionalParams?: {
        page?: number;
        perPage?: number;
    }): Promise<ServiceAccountsListResponse>;
    /**
     * @summary Create
  
     * @returns {Promise<ServiceAccountsCreateResponse>} - The promise with the result
     */
    create(input: ServiceAccountsCreateRequest): Promise<ServiceAccountsCreateResponse>;
    /**
     * @summary Retrieve
  
     * @param slug Slug of the service account
     * @returns {Promise<ServiceAccountsGetResponse>} - The promise with the result
     */
    get(slug: string): Promise<ServiceAccountsGetResponse>;
    /**
     * @summary Update
  
     * @param slug Slug of the service account
     * @returns {Promise<ServiceAccountsUpdateResponse>} - The promise with the result
     */
    update(input: ServiceAccountsUpdateRequest, slug: string): Promise<ServiceAccountsUpdateResponse>;
    /**
     * @summary Delete
  
     * @param slug Slug of the service account
     * @returns {Promise<any>} - The promise with the result
     */
    delete(slug: string): Promise<any>;
}

interface GroupsListResponse {
    groups?: {
        name?: string;
        slug?: string;
        created_at?: string;
        default_project_role?: DefaultProjectRole$3;
    }[];
}
interface DefaultProjectRole$3 {
    identifier?: string;
}

interface GroupsCreateResponse {
    group?: Group$2;
}
interface Group$2 {
    name?: string;
    slug?: string;
    created_at?: string;
    default_project_role?: DefaultProjectRole$2;
    projects?: {
        name?: string;
        slug?: string;
        role?: Role$2;
    }[];
    members?: {
        slug?: string;
        type_?: string;
    }[];
}
interface DefaultProjectRole$2 {
    identifier?: string;
}
interface Role$2 {
    identifier?: string;
}

interface GroupsCreateRequest {
    name: string;
    /**
     * Identifier of the project role
     */
    default_project_role?: string;
}

interface GroupsGetResponse {
    group?: Group$1;
}
interface Group$1 {
    name?: string;
    slug?: string;
    created_at?: string;
    default_project_role?: DefaultProjectRole$1;
    projects?: {
        name?: string;
        slug?: string;
        role?: Role$1;
    }[];
    members?: {
        slug?: string;
        type_?: string;
    }[];
}
interface DefaultProjectRole$1 {
    identifier?: string;
}
interface Role$1 {
    identifier?: string;
}

interface GroupsUpdateResponse {
    group?: Group;
}
interface Group {
    name?: string;
    slug?: string;
    created_at?: string;
    default_project_role?: DefaultProjectRole;
    projects?: {
        name?: string;
        slug?: string;
        role?: Role;
    }[];
    members?: {
        slug?: string;
        type_?: string;
    }[];
}
interface DefaultProjectRole {
    identifier?: string;
}
interface Role {
    identifier?: string;
}

interface GroupsUpdateRequest {
    name?: string;
    /**
     * Identifier of the project role
     */
    default_project_role?: string;
}

declare type Type = 'workplace_user';
interface AddMemberRequest {
    /**
     * The member's slug
     */
    slug: string;
    type_: Type;
}

declare type GroupsType = 'workplace_user';

declare class GroupsService extends BaseService {
    /**
     * @summary List
  
     * @param optionalParams - Optional parameters
     * @param optionalParams.page - Needed input variable
     * @param optionalParams.perPage - Needed input variable
     * @returns {Promise<GroupsListResponse>} - The promise with the result
     */
    list(optionalParams?: {
        page?: number;
        perPage?: number;
    }): Promise<GroupsListResponse>;
    /**
     * @summary Create
  
     * @returns {Promise<GroupsCreateResponse>} - The promise with the result
     */
    create(input: GroupsCreateRequest): Promise<GroupsCreateResponse>;
    /**
     * @summary Retrieve
  
     * @param slug The group's slug
     * @returns {Promise<GroupsGetResponse>} - The promise with the result
     */
    get(slug: string): Promise<GroupsGetResponse>;
    /**
     * @summary Update
  
     * @param slug The group's slug
     * @returns {Promise<GroupsUpdateResponse>} - The promise with the result
     */
    update(input: GroupsUpdateRequest, slug: string): Promise<GroupsUpdateResponse>;
    /**
     * @summary Delete
  
     * @param slug The group's slug
     * @returns {Promise<any>} - The promise with the result
     */
    delete(slug: string): Promise<any>;
    /**
     * @summary Add Member
  
     * @param slug The group's slug
     * @returns {Promise<any>} - The promise with the result
     */
    addMember(input: AddMemberRequest, slug: string): Promise<any>;
    /**
     * @summary Delete Member
  
     * @param slug The group's slug
     * @param type_ Needed input variable
     * @param memberSlug The member's slug
     * @returns {Promise<any>} - The promise with the result
     */
    deleteMember(slug: string, type: GroupsType, memberSlug: string): Promise<any>;
}

interface UsersListResponse {
    workplace_users?: {
        id?: string;
        access?: string;
        created_at?: string;
        user?: User$1;
    }[];
    page?: number;
    success?: boolean;
}
interface User$1 {
    email?: string;
    name?: string;
    username?: string;
    profile_image_url?: string;
}

interface UsersGetResponse {
    workplace_user?: WorkplaceUser;
    success?: boolean;
}
interface WorkplaceUser {
    id?: string;
    access?: string;
    created_at?: string;
    user?: User;
}
interface User {
    email?: string;
    name?: string;
    username?: string;
    profile_image_url?: string;
}

declare class UsersService extends BaseService {
    /**
     * @summary List
     * @description Get all users within a workplace
  
     * @param optionalParams - Optional parameters
     * @param optionalParams.page - The page of users to fetch
     * @returns {Promise<UsersListResponse>} - The promise with the result
     */
    list(optionalParams?: {
        page?: number;
    }): Promise<UsersListResponse>;
    /**
     * @summary Retrieve
     * @description Get a specific user in a workplace
  
     * @param slug The slug of the workplace user
     * @returns {Promise<UsersGetResponse>} - The promise with the result
     */
    get(slug: string): Promise<UsersGetResponse>;
}

type index$j_DownloadResponse = DownloadResponse;
type index$j_Format = Format;
type index$j_NameTransformer = NameTransformer;
type index$j_NamesResponse = NamesResponse;
type index$j_SecretsGetResponse = SecretsGetResponse;
type index$j_SecretsListResponse = SecretsListResponse;
type index$j_UpdateNoteRequest = UpdateNoteRequest;
type index$j_UpdateNoteResponse = UpdateNoteResponse;
type index$j_UpdateRequest = UpdateRequest;
type index$j_UpdateResponse = UpdateResponse;
declare namespace index$j {
  export {
    index$j_DownloadResponse as DownloadResponse,
    index$j_Format as Format,
    index$j_NameTransformer as NameTransformer,
    index$j_NamesResponse as NamesResponse,
    index$j_SecretsGetResponse as SecretsGetResponse,
    index$j_SecretsListResponse as SecretsListResponse,
    index$j_UpdateNoteRequest as UpdateNoteRequest,
    index$j_UpdateNoteResponse as UpdateNoteResponse,
    index$j_UpdateRequest as UpdateRequest,
    index$j_UpdateResponse as UpdateResponse,
  };
}

type index$i_AddRequest = AddRequest;
type index$i_AddResponse = AddResponse;
type index$i_ProjectMembersGetResponse = ProjectMembersGetResponse;
type index$i_ProjectMembersListResponse = ProjectMembersListResponse;
type index$i_ProjectMembersUpdateRequest = ProjectMembersUpdateRequest;
type index$i_ProjectMembersUpdateResponse = ProjectMembersUpdateResponse;
declare namespace index$i {
  export {
    index$i_AddRequest as AddRequest,
    index$i_AddResponse as AddResponse,
    index$i_ProjectMembersGetResponse as ProjectMembersGetResponse,
    index$i_ProjectMembersListResponse as ProjectMembersListResponse,
    index$i_ProjectMembersUpdateRequest as ProjectMembersUpdateRequest,
    index$i_ProjectMembersUpdateResponse as ProjectMembersUpdateResponse,
    Type$1 as Type,
  };
}

type index$h_AddMemberRequest = AddMemberRequest;
type index$h_GroupsCreateRequest = GroupsCreateRequest;
type index$h_GroupsCreateResponse = GroupsCreateResponse;
type index$h_GroupsGetResponse = GroupsGetResponse;
type index$h_GroupsListResponse = GroupsListResponse;
type index$h_GroupsType = GroupsType;
type index$h_GroupsUpdateRequest = GroupsUpdateRequest;
type index$h_GroupsUpdateResponse = GroupsUpdateResponse;
declare namespace index$h {
  export {
    index$h_AddMemberRequest as AddMemberRequest,
    index$h_GroupsCreateRequest as GroupsCreateRequest,
    index$h_GroupsCreateResponse as GroupsCreateResponse,
    index$h_GroupsGetResponse as GroupsGetResponse,
    index$h_GroupsListResponse as GroupsListResponse,
    index$h_GroupsType as GroupsType,
    index$h_GroupsUpdateRequest as GroupsUpdateRequest,
    index$h_GroupsUpdateResponse as GroupsUpdateResponse,
  };
}

type index$g_CreateRequest = CreateRequest;
type index$g_CreateResponse = CreateResponse;
type index$g_DeleteRequest = DeleteRequest;
type index$g_ListResponse = ListResponse;
type index$g_ProjectsGetResponse = ProjectsGetResponse;
type index$g_ProjectsUpdateRequest = ProjectsUpdateRequest;
type index$g_ProjectsUpdateResponse = ProjectsUpdateResponse;
declare namespace index$g {
  export {
    index$g_CreateRequest as CreateRequest,
    index$g_CreateResponse as CreateResponse,
    index$g_DeleteRequest as DeleteRequest,
    index$g_ListResponse as ListResponse,
    index$g_ProjectsGetResponse as ProjectsGetResponse,
    index$g_ProjectsUpdateRequest as ProjectsUpdateRequest,
    index$g_ProjectsUpdateResponse as ProjectsUpdateResponse,
  };
}

type index$f_ConfigLogsListResponse = ConfigLogsListResponse;
type index$f_GetResponse = GetResponse;
type index$f_RollbackResponse = RollbackResponse;
declare namespace index$f {
  export {
    index$f_ConfigLogsListResponse as ConfigLogsListResponse,
    index$f_GetResponse as GetResponse,
    index$f_RollbackResponse as RollbackResponse,
  };
}

type index$e_EnvironmentsCreateRequest = EnvironmentsCreateRequest;
type index$e_EnvironmentsCreateResponse = EnvironmentsCreateResponse;
type index$e_EnvironmentsGetResponse = EnvironmentsGetResponse;
type index$e_EnvironmentsListResponse = EnvironmentsListResponse;
type index$e_RenameRequest = RenameRequest;
type index$e_RenameResponse = RenameResponse;
declare namespace index$e {
  export {
    index$e_EnvironmentsCreateRequest as EnvironmentsCreateRequest,
    index$e_EnvironmentsCreateResponse as EnvironmentsCreateResponse,
    index$e_EnvironmentsGetResponse as EnvironmentsGetResponse,
    index$e_EnvironmentsListResponse as EnvironmentsListResponse,
    index$e_RenameRequest as RenameRequest,
    index$e_RenameResponse as RenameResponse,
  };
}

type index$d_AddTrustedIpRequest = AddTrustedIpRequest;
type index$d_AddTrustedIpResponse = AddTrustedIpResponse;
type index$d_CloneRequest = CloneRequest;
type index$d_CloneResponse = CloneResponse;
type index$d_ConfigsCreateRequest = ConfigsCreateRequest;
type index$d_ConfigsCreateResponse = ConfigsCreateResponse;
type index$d_ConfigsDeleteRequest = ConfigsDeleteRequest;
type index$d_ConfigsGetResponse = ConfigsGetResponse;
type index$d_ConfigsListResponse = ConfigsListResponse;
type index$d_ConfigsUpdateRequest = ConfigsUpdateRequest;
type index$d_ConfigsUpdateResponse = ConfigsUpdateResponse;
type index$d_DeleteResponse = DeleteResponse;
type index$d_DeleteTrustedIpRequest = DeleteTrustedIpRequest;
type index$d_ListTrustedIpsResponse = ListTrustedIpsResponse;
type index$d_LockRequest = LockRequest;
type index$d_LockResponse = LockResponse;
type index$d_UnlockRequest = UnlockRequest;
type index$d_UnlockResponse = UnlockResponse;
declare namespace index$d {
  export {
    index$d_AddTrustedIpRequest as AddTrustedIpRequest,
    index$d_AddTrustedIpResponse as AddTrustedIpResponse,
    index$d_CloneRequest as CloneRequest,
    index$d_CloneResponse as CloneResponse,
    index$d_ConfigsCreateRequest as ConfigsCreateRequest,
    index$d_ConfigsCreateResponse as ConfigsCreateResponse,
    index$d_ConfigsDeleteRequest as ConfigsDeleteRequest,
    index$d_ConfigsGetResponse as ConfigsGetResponse,
    index$d_ConfigsListResponse as ConfigsListResponse,
    index$d_ConfigsUpdateRequest as ConfigsUpdateRequest,
    index$d_ConfigsUpdateResponse as ConfigsUpdateResponse,
    index$d_DeleteResponse as DeleteResponse,
    index$d_DeleteTrustedIpRequest as DeleteTrustedIpRequest,
    index$d_ListTrustedIpsResponse as ListTrustedIpsResponse,
    index$d_LockRequest as LockRequest,
    index$d_LockResponse as LockResponse,
    index$d_UnlockRequest as UnlockRequest,
    index$d_UnlockResponse as UnlockResponse,
  };
}

type index$c_DeleteResponse = DeleteResponse;
type index$c_ServiceTokensCreateRequest = ServiceTokensCreateRequest;
type index$c_ServiceTokensCreateResponse = ServiceTokensCreateResponse;
type index$c_ServiceTokensDeleteRequest = ServiceTokensDeleteRequest;
type index$c_ServiceTokensListResponse = ServiceTokensListResponse;
declare namespace index$c {
  export {
    index$c_DeleteResponse as DeleteResponse,
    index$c_ServiceTokensCreateRequest as ServiceTokensCreateRequest,
    index$c_ServiceTokensCreateResponse as ServiceTokensCreateResponse,
    index$c_ServiceTokensDeleteRequest as ServiceTokensDeleteRequest,
    index$c_ServiceTokensListResponse as ServiceTokensListResponse,
  };
}

type index$b_ActivityLogsListResponse = ActivityLogsListResponse;
type index$b_RetrieveResponse = RetrieveResponse;
declare namespace index$b {
  export {
    index$b_ActivityLogsListResponse as ActivityLogsListResponse,
    index$b_RetrieveResponse as RetrieveResponse,
  };
}

type index$a_WorkplaceGetResponse = WorkplaceGetResponse;
type index$a_WorkplaceUpdateRequest = WorkplaceUpdateRequest;
type index$a_WorkplaceUpdateResponse = WorkplaceUpdateResponse;
declare namespace index$a {
  export {
    index$a_WorkplaceGetResponse as WorkplaceGetResponse,
    index$a_WorkplaceUpdateRequest as WorkplaceUpdateRequest,
    index$a_WorkplaceUpdateResponse as WorkplaceUpdateResponse,
  };
}

type index$9_GetUserResponse = GetUserResponse;
declare namespace index$9 {
  export {
    index$9_GetUserResponse as GetUserResponse,
  };
}

type index$8_IssueLeaseRequest = IssueLeaseRequest;
type index$8_IssueLeaseResponse = IssueLeaseResponse;
type index$8_RevokeLeaseRequest = RevokeLeaseRequest;
type index$8_RevokeLeaseResponse = RevokeLeaseResponse;
declare namespace index$8 {
  export {
    index$8_IssueLeaseRequest as IssueLeaseRequest,
    index$8_IssueLeaseResponse as IssueLeaseResponse,
    index$8_RevokeLeaseRequest as RevokeLeaseRequest,
    index$8_RevokeLeaseResponse as RevokeLeaseResponse,
  };
}

type index$7_IntegrationsCreateRequest = IntegrationsCreateRequest;
type index$7_IntegrationsCreateResponse = IntegrationsCreateResponse;
type index$7_IntegrationsDeleteResponse = IntegrationsDeleteResponse;
type index$7_IntegrationsGetResponse = IntegrationsGetResponse;
type index$7_IntegrationsListResponse = IntegrationsListResponse;
type index$7_IntegrationsUpdateRequest = IntegrationsUpdateRequest;
type index$7_IntegrationsUpdateResponse = IntegrationsUpdateResponse;
declare namespace index$7 {
  export {
    index$7_IntegrationsCreateRequest as IntegrationsCreateRequest,
    index$7_IntegrationsCreateResponse as IntegrationsCreateResponse,
    index$7_IntegrationsDeleteResponse as IntegrationsDeleteResponse,
    index$7_IntegrationsGetResponse as IntegrationsGetResponse,
    index$7_IntegrationsListResponse as IntegrationsListResponse,
    index$7_IntegrationsUpdateRequest as IntegrationsUpdateRequest,
    index$7_IntegrationsUpdateResponse as IntegrationsUpdateResponse,
  };
}

type index$6_SyncsCreateRequest = SyncsCreateRequest;
type index$6_SyncsCreateResponse = SyncsCreateResponse;
type index$6_SyncsDeleteResponse = SyncsDeleteResponse;
type index$6_SyncsGetResponse = SyncsGetResponse;
declare namespace index$6 {
  export {
    index$6_SyncsCreateRequest as SyncsCreateRequest,
    index$6_SyncsCreateResponse as SyncsCreateResponse,
    index$6_SyncsDeleteResponse as SyncsDeleteResponse,
    index$6_SyncsGetResponse as SyncsGetResponse,
  };
}

type index$5_MeResponse = MeResponse;
type index$5_RevokeRequest = RevokeRequest;
declare namespace index$5 {
  export {
    index$5_MeResponse as MeResponse,
    index$5_RevokeRequest as RevokeRequest,
  };
}

type index$4_ListPermissionsResponse = ListPermissionsResponse;
type index$4_WorkplaceRolesCreateResponse = WorkplaceRolesCreateResponse;
type index$4_WorkplaceRolesGetResponse = WorkplaceRolesGetResponse;
type index$4_WorkplaceRolesListResponse = WorkplaceRolesListResponse;
type index$4_WorkplaceRolesUpdateResponse = WorkplaceRolesUpdateResponse;
declare namespace index$4 {
  export {
    index$4_ListPermissionsResponse as ListPermissionsResponse,
    index$4_WorkplaceRolesCreateResponse as WorkplaceRolesCreateResponse,
    index$4_WorkplaceRolesGetResponse as WorkplaceRolesGetResponse,
    index$4_WorkplaceRolesListResponse as WorkplaceRolesListResponse,
    index$4_WorkplaceRolesUpdateResponse as WorkplaceRolesUpdateResponse,
  };
}

type index$3_ProjectRolesCreateResponse = ProjectRolesCreateResponse;
type index$3_ProjectRolesGetResponse = ProjectRolesGetResponse;
type index$3_ProjectRolesListPermissionsResponse = ProjectRolesListPermissionsResponse;
type index$3_ProjectRolesListResponse = ProjectRolesListResponse;
type index$3_ProjectRolesUpdateResponse = ProjectRolesUpdateResponse;
declare namespace index$3 {
  export {
    index$3_ProjectRolesCreateResponse as ProjectRolesCreateResponse,
    index$3_ProjectRolesGetResponse as ProjectRolesGetResponse,
    index$3_ProjectRolesListPermissionsResponse as ProjectRolesListPermissionsResponse,
    index$3_ProjectRolesListResponse as ProjectRolesListResponse,
    index$3_ProjectRolesUpdateResponse as ProjectRolesUpdateResponse,
  };
}

type index$2_InvitesListResponse = InvitesListResponse;
declare namespace index$2 {
  export {
    index$2_InvitesListResponse as InvitesListResponse,
  };
}

type index$1_ServiceAccountsCreateRequest = ServiceAccountsCreateRequest;
type index$1_ServiceAccountsCreateResponse = ServiceAccountsCreateResponse;
type index$1_ServiceAccountsGetResponse = ServiceAccountsGetResponse;
type index$1_ServiceAccountsListResponse = ServiceAccountsListResponse;
type index$1_ServiceAccountsUpdateRequest = ServiceAccountsUpdateRequest;
type index$1_ServiceAccountsUpdateResponse = ServiceAccountsUpdateResponse;
declare namespace index$1 {
  export {
    index$1_ServiceAccountsCreateRequest as ServiceAccountsCreateRequest,
    index$1_ServiceAccountsCreateResponse as ServiceAccountsCreateResponse,
    index$1_ServiceAccountsGetResponse as ServiceAccountsGetResponse,
    index$1_ServiceAccountsListResponse as ServiceAccountsListResponse,
    index$1_ServiceAccountsUpdateRequest as ServiceAccountsUpdateRequest,
    index$1_ServiceAccountsUpdateResponse as ServiceAccountsUpdateResponse,
  };
}

type index_UsersGetResponse = UsersGetResponse;
type index_UsersListResponse = UsersListResponse;
declare namespace index {
  export {
    index_UsersGetResponse as UsersGetResponse,
    index_UsersListResponse as UsersListResponse,
  };
}

declare type Config = {
    accessToken?: string;
};
declare class DopplerSDK {
    projects: ProjectsService;
    secrets: SecretsService;
    configLogs: ConfigLogsService;
    environments: EnvironmentsService;
    configs: ConfigsService;
    activityLogs: ActivityLogsService;
    workplace: WorkplaceService;
    serviceTokens: ServiceTokensService;
    audit: AuditService;
    dynamicSecrets: DynamicSecretsService;
    auth: AuthService;
    integrations: IntegrationsService;
    syncs: SyncsService;
    workplaceRoles: WorkplaceRolesService;
    projectRoles: ProjectRolesService;
    projectMembers: ProjectMembersService;
    invites: InvitesService;
    serviceAccounts: ServiceAccountsService;
    groups: GroupsService;
    users: UsersService;
    constructor({ accessToken }: Config);
    setBaseUrl(url: string): void;
    setAccessToken(accessToken: string): void;
}

export { ActivityLogsListResponse, index$b as ActivityLogsModels, AddMemberRequest, AddRequest, AddResponse, AddTrustedIpRequest, AddTrustedIpResponse, index$9 as AuditModels, index$5 as AuthModels, CloneRequest, CloneResponse, ConfigLogsListResponse, index$f as ConfigLogsModels, ConfigsCreateRequest, ConfigsCreateResponse, ConfigsDeleteRequest, ConfigsGetResponse, ConfigsListResponse, index$d as ConfigsModels, ConfigsUpdateRequest, ConfigsUpdateResponse, CreateRequest, CreateResponse, DeleteRequest, DeleteResponse, DeleteTrustedIpRequest, DopplerSDK, DownloadResponse, index$8 as DynamicSecretsModels, EnvironmentsCreateRequest, EnvironmentsCreateResponse, EnvironmentsGetResponse, EnvironmentsListResponse, index$e as EnvironmentsModels, Format, GetResponse, GetUserResponse, GroupsCreateRequest, GroupsCreateResponse, GroupsGetResponse, GroupsListResponse, index$h as GroupsModels, GroupsType, GroupsUpdateRequest, GroupsUpdateResponse, IntegrationsCreateRequest, IntegrationsCreateResponse, IntegrationsDeleteResponse, IntegrationsGetResponse, IntegrationsListResponse, index$7 as IntegrationsModels, IntegrationsUpdateRequest, IntegrationsUpdateResponse, InvitesListResponse, index$2 as InvitesModels, IssueLeaseRequest, IssueLeaseResponse, ListPermissionsResponse, ListResponse, ListTrustedIpsResponse, LockRequest, LockResponse, MeResponse, NameTransformer, NamesResponse, ProjectMembersGetResponse, ProjectMembersListResponse, index$i as ProjectMembersModels, ProjectMembersUpdateRequest, ProjectMembersUpdateResponse, ProjectRolesCreateResponse, ProjectRolesGetResponse, ProjectRolesListPermissionsResponse, ProjectRolesListResponse, index$3 as ProjectRolesModels, ProjectRolesUpdateResponse, ProjectsGetResponse, index$g as ProjectsModels, ProjectsUpdateRequest, ProjectsUpdateResponse, RenameRequest, RenameResponse, RetrieveResponse, RevokeLeaseRequest, RevokeLeaseResponse, RevokeRequest, RollbackResponse, SecretsGetResponse, SecretsListResponse, index$j as SecretsModels, ServiceAccountsCreateRequest, ServiceAccountsCreateResponse, ServiceAccountsGetResponse, ServiceAccountsListResponse, index$1 as ServiceAccountsModels, ServiceAccountsUpdateRequest, ServiceAccountsUpdateResponse, ServiceTokensCreateRequest, ServiceTokensCreateResponse, ServiceTokensDeleteRequest, ServiceTokensListResponse, index$c as ServiceTokensModels, SyncsCreateRequest, SyncsCreateResponse, SyncsDeleteResponse, SyncsGetResponse, index$6 as SyncsModels, Type$1 as Type, UnlockRequest, UnlockResponse, UpdateNoteRequest, UpdateNoteResponse, UpdateRequest, UpdateResponse, UsersGetResponse, UsersListResponse, index as UsersModels, WorkplaceGetResponse, index$a as WorkplaceModels, WorkplaceRolesCreateResponse, WorkplaceRolesGetResponse, WorkplaceRolesListResponse, index$4 as WorkplaceRolesModels, WorkplaceRolesUpdateResponse, WorkplaceUpdateRequest, WorkplaceUpdateResponse, DopplerSDK as default };
