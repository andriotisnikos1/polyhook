"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ActivityLogsModels: () => activityLogs_exports,
  AuditModels: () => audit_exports,
  AuthModels: () => auth_exports,
  ConfigLogsModels: () => configLogs_exports,
  ConfigsModels: () => configs_exports,
  DopplerSDK: () => DopplerSDK,
  DynamicSecretsModels: () => dynamicSecrets_exports,
  EnvironmentsModels: () => environments_exports,
  GroupsModels: () => groups_exports,
  IntegrationsModels: () => integrations_exports,
  InvitesModels: () => invites_exports,
  ProjectMembersModels: () => projectMembers_exports,
  ProjectRolesModels: () => projectRoles_exports,
  ProjectsModels: () => projects_exports,
  SecretsModels: () => secrets_exports,
  ServiceAccountsModels: () => serviceAccounts_exports,
  ServiceTokensModels: () => serviceTokens_exports,
  SyncsModels: () => syncs_exports,
  UsersModels: () => users_exports,
  WorkplaceModels: () => workplace_exports,
  WorkplaceRolesModels: () => workplaceRoles_exports,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);

// src/http/errors/base.ts
var BaseHTTPError = class extends Error {
  constructor(detail = "") {
    super(detail || "An Unknown HTTP Error Occurred");
    this.title = "Internal Server Error";
    this.statusCode = 500;
    this.detail = detail;
    this.stack = new Error().stack;
  }
};

// src/http/errors/BadRequest.ts
var BadRequest = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 400;
    this.title = "Bad Request";
  }
};

// src/http/errors/Unauthorized.ts
var Unauthorized = class extends BaseHTTPError {
  constructor(detail = "", wwwAuthenticate) {
    super(detail);
    this.statusCode = 401;
    this.title = "Unauthorized";
    this.wwwAuthenticate = wwwAuthenticate;
  }
};

// src/http/errors/PaymentRequired.ts
var PaymentRequired = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 402;
    this.title = "Payment Required";
  }
};

// src/http/errors/Forbidden.ts
var Forbidden = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 403;
    this.title = "Forbidden";
  }
};

// src/http/errors/NotFound.ts
var NotFound = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 404;
    this.title = "Not Found";
  }
};

// src/http/errors/MethodNotAllowed.ts
var MethodNotAllowed = class extends BaseHTTPError {
  constructor(detail = "", allow) {
    super(detail);
    this.statusCode = 405;
    this.title = "Method Not Allowed";
    this.allow = allow;
  }
};

// src/http/errors/NotAcceptable.ts
var NotAcceptable = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 406;
    this.title = "Not Acceptable";
  }
};

// src/http/errors/ProxyAuthenticationRequired.ts
var ProxyAuthenticationRequired = class extends BaseHTTPError {
  constructor(detail = "", proxyAuthenticate) {
    super(detail);
    this.statusCode = 407;
    this.title = "Proxy Authentication Required";
    this.proxyAuthenticate = proxyAuthenticate;
  }
};

// src/http/errors/RequestTimeout.ts
var RequestTimeout = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 408;
    this.title = "Request Timeout";
  }
};

// src/http/errors/Conflict.ts
var Conflict = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 409;
    this.title = "Conflict";
  }
};

// src/http/errors/Gone.ts
var Gone = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 410;
    this.title = "Gone";
  }
};

// src/http/errors/LengthRequired.ts
var LengthRequired = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 411;
    this.title = "LengthRequired";
  }
};

// src/http/errors/PreconditionFailed.ts
var PreconditionFailed = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 412;
    this.title = "PreconditionFailed";
  }
};

// src/http/errors/PayloadTooLarge.ts
var PayloadTooLarge = class extends BaseHTTPError {
  constructor(detail = "", retryAfter = null) {
    super(detail);
    this.statusCode = 413;
    this.title = "Payload Too Large";
    this.retryAfter = retryAfter;
  }
};

// src/http/errors/UriTooLong.ts
var UriTooLong = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 414;
    this.title = "URI Too Long";
  }
};

// src/http/errors/UnsupportedMediaType.ts
var UnsupportedMediaType = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 415;
    this.title = "Unsupported Media Type";
  }
};

// src/http/errors/RangeNotSatisfiable.ts
var RangeNotSatisfiable = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 416;
    this.title = "Range Not Satisfiable";
  }
};

// src/http/errors/ExpectationFailed.ts
var ExpectationFailed = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 417;
    this.title = "Expectation Failed";
  }
};

// src/http/errors/MisdirectedRequest.ts
var MisdirectedRequest = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 421;
    this.title = "Misdirected Request";
  }
};

// src/http/errors/UnprocessableEntity.ts
var UnprocessableEntity = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 422;
    this.title = "Unprocessable Entity";
  }
};

// src/http/errors/Locked.ts
var Locked = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 423;
    this.title = "Locked";
  }
};

// src/http/errors/FailedDependency.ts
var FailedDependency = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 424;
    this.title = "Failed Dependency";
  }
};

// src/http/errors/TooEarly.ts
var TooEarly = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 425;
    this.title = "Too Early";
  }
};

// src/http/errors/UpgradeRequired.ts
var UpgradeRequired = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 426;
    this.title = "Upgrade Required";
  }
};

// src/http/errors/PreconditionRequired.ts
var PreconditionRequired = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 428;
    this.title = "Precondition Required";
  }
};

// src/http/errors/TooManyRequests.ts
var TooManyRequests = class extends BaseHTTPError {
  constructor(detail = "", retryAfter = null) {
    super(detail);
    this.statusCode = 429;
    this.title = "Too Many Requests";
    this.retryAfter = retryAfter;
  }
};

// src/http/errors/RequestHeaderFieldsTooLarge.ts
var RequestHeaderFieldsTooLarge = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 431;
    this.title = "Request Header Fields Too Large";
  }
};

// src/http/errors/UnavailableForLegalReasons.ts
var UnavailableForLegalReasons = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 451;
    this.title = "Unavailable For Legal Reasons";
  }
};

// src/http/errors/InternalServerError.ts
var InternalServerError = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 500;
    this.title = "Internal Server Error";
  }
};

// src/http/errors/NotImplemented.ts
var NotImplemented = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 501;
    this.title = "Not Implemented";
  }
};

// src/http/errors/BadGateway.ts
var BadGateway = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 502;
    this.title = "Bad Gateway";
  }
};

// src/http/errors/ServiceUnavailable.ts
var ServiceUnavailable = class extends BaseHTTPError {
  constructor(detail = "", retryAfter = null) {
    super(detail);
    this.statusCode = 503;
    this.title = "Service Unavailable";
    this.retryAfter = retryAfter;
  }
};

// src/http/errors/GatewayTimeout.ts
var GatewayTimeout = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 504;
    this.title = "Gateway Timeout";
  }
};

// src/http/errors/HttpVersionNotSupported.ts
var HttpVersionNotSupported = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 505;
    this.title = "HTTP Version Not Supported";
  }
};

// src/http/errors/VariantAlsoNegotiates.ts
var VariantAlsoNegotiates = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 506;
    this.title = "Variant Also Negotiates";
  }
};

// src/http/errors/UnsufficientStorage.ts
var UnsufficientStorage = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 507;
    this.title = "Unsufficient Storage";
  }
};

// src/http/errors/LoopDetected.ts
var LoopDetected = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 508;
    this.title = "Loop Detected";
  }
};

// src/http/errors/NotExtended.ts
var NotExtended = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 510;
    this.title = "Not Extended";
  }
};

// src/http/errors/NetworkAuthenticationRequired.ts
var NetworkAuthenticationRequired = class extends BaseHTTPError {
  constructor(detail = "") {
    super(detail);
    this.statusCode = 511;
    this.title = "Network Authentication Required";
  }
};

// src/http/httpExceptions.ts
var statusCodeToErrorFunction = {
  400: BadRequest,
  401: Unauthorized,
  402: PaymentRequired,
  403: Forbidden,
  404: NotFound,
  405: MethodNotAllowed,
  406: NotAcceptable,
  407: ProxyAuthenticationRequired,
  408: RequestTimeout,
  409: Conflict,
  410: Gone,
  411: LengthRequired,
  412: PreconditionFailed,
  413: PayloadTooLarge,
  414: UriTooLong,
  415: UnsupportedMediaType,
  416: RangeNotSatisfiable,
  417: ExpectationFailed,
  421: MisdirectedRequest,
  422: UnprocessableEntity,
  423: Locked,
  424: FailedDependency,
  425: TooEarly,
  426: UpgradeRequired,
  428: PreconditionRequired,
  429: TooManyRequests,
  431: RequestHeaderFieldsTooLarge,
  451: UnavailableForLegalReasons,
  500: InternalServerError,
  501: NotImplemented,
  502: BadGateway,
  503: ServiceUnavailable,
  504: GatewayTimeout,
  505: HttpVersionNotSupported,
  506: VariantAlsoNegotiates,
  507: UnsufficientStorage,
  508: LoopDetected,
  510: NotExtended,
  511: NetworkAuthenticationRequired
};
function throwHttpError(response) {
  switch (response.status) {
    case 401:
      throw new Unauthorized(response.data, response.headers["WWW-Authenticate"]);
    case 405:
      throw new MethodNotAllowed(response.data, response.headers.allowed);
    case 407:
      throw new ProxyAuthenticationRequired(response.data, response.headers["Proxy-Authenticate"]);
    case 413:
      throw new PayloadTooLarge(response.data, response.headers["Retry-After"]);
    case 429:
      throw new TooManyRequests(response.data, response.headers["Retry-After"]);
    case 503:
      throw new ServiceUnavailable(response.data, response.headers["Retry-After"]);
    default:
      if (response.status in statusCodeToErrorFunction) {
        throw new statusCodeToErrorFunction[response.status](response.data);
      } else {
        const error = new BaseHTTPError(response.data);
        error.statusCode = response.status;
        error.title = "unknown error";
        throw error;
      }
  }
}

// src/http/HTTPLibrary.ts
var _HTTPLibrary = class {
  constructor() {
    this.userAgentHeader = {
      "User-Agent": "liblab/0.1.17 DopplerSDK/1.2.0 typescript/5.2.2"
    };
    this.retryAttempts = 3;
    this.retryDelayMs = 150;
    this.requestMapper = /* @__PURE__ */ new Map([
      ["type_", "type"]
    ]);
  }
  async get(url, input, headers, retry = false) {
    const request = () => _HTTPLibrary.httpRequest(
      "GET",
      url,
      {
        ...headers,
        ...this.getUserAgentHeader(),
        "content-type": "application/json"
      },
      Object.keys(input).length > 0 ? JSON.stringify(_HTTPLibrary.convertKeysWithMapper(input, this.requestMapper)) : void 0
    );
    const response = retry ? await this.retry(this.retryAttempts, request, this.retryDelayMs) : await request();
    return _HTTPLibrary.handleResponse(response);
  }
  async post(url, input, headers, retry = false) {
    const request = () => _HTTPLibrary.httpRequest(
      "POST",
      url,
      {
        ...headers,
        ...this.getUserAgentHeader(),
        "content-type": "application/json"
      },
      JSON.stringify(_HTTPLibrary.convertKeysWithMapper(input, this.requestMapper))
    );
    const response = retry ? await this.retry(this.retryAttempts, request, this.retryDelayMs) : await request();
    return _HTTPLibrary.handleResponse(response);
  }
  async delete(url, input, headers, retry = false) {
    const request = () => _HTTPLibrary.httpRequest(
      "DELETE",
      url,
      {
        ...headers,
        ...this.getUserAgentHeader(),
        "content-type": "application/json"
      },
      JSON.stringify(_HTTPLibrary.convertKeysWithMapper(input, this.requestMapper))
    );
    const response = retry ? await this.retry(this.retryAttempts, request, this.retryDelayMs) : await request();
    return _HTTPLibrary.handleResponse(response);
  }
  async put(url, input, headers, retry = false) {
    const request = () => _HTTPLibrary.httpRequest(
      "PUT",
      url,
      {
        ...headers,
        ...this.getUserAgentHeader(),
        "content-type": "application/json"
      },
      JSON.stringify(_HTTPLibrary.convertKeysWithMapper(input, this.requestMapper))
    );
    const response = retry ? await this.retry(this.retryAttempts, request, this.retryDelayMs) : await request();
    return _HTTPLibrary.handleResponse(response);
  }
  async patch(url, input, headers, retry = false) {
    const request = () => _HTTPLibrary.httpRequest(
      "PATCH",
      url,
      {
        ...headers,
        ...this.getUserAgentHeader(),
        "content-type": "application/json"
      },
      JSON.stringify(_HTTPLibrary.convertKeysWithMapper(input, this.requestMapper))
    );
    const response = retry ? await this.retry(this.retryAttempts, request, this.retryDelayMs) : await request();
    return _HTTPLibrary.handleResponse(response);
  }
  async retry(retries, callbackFn, delay = 500) {
    let result;
    try {
      result = await callbackFn();
      if (![500, 503, 504].includes(result.status)) {
        return result;
      }
      if (retries > 1) {
        await new Promise((resolve) => setTimeout(resolve, delay));
        result = await this.retry(retries - 1, callbackFn, delay * 2);
      }
    } catch (e) {
      if (retries > 1) {
        await new Promise((resolve) => setTimeout(resolve, delay));
        result = await this.retry(retries - 1, callbackFn, delay * 2);
      } else {
        throw e;
      }
    }
    return result;
  }
  static handleResponse(response) {
    if (response.status >= 400) {
      throwHttpError(response);
    }
    response.data = _HTTPLibrary.convertKeysWithMapper(response.data, this.responseMapper);
    return { data: response.data, status: response.status };
  }
  static async httpRequest(method, url, headers, body = "") {
    const parsedUrl = new URL(url);
    const isHttps = parsedUrl.protocol === "https:";
    const options = {
      method,
      headers
    };
    const httpModule = isHttps ? await import("https") : await import("http");
    if (isHttps) {
      options.minVersion = "TLSv1.2";
    }
    return new Promise((resolve, reject) => {
      const req = httpModule.request(url, options, (res) => {
        let responseBody = "";
        res.on("data", (chunk) => {
          responseBody += chunk;
        });
        res.on("end", () => {
          if (responseBody === "") {
            responseBody = "{}";
          }
          resolve({
            status: res.statusCode,
            headers: res.headers,
            data: JSON.parse(responseBody)
          });
        });
      });
      req.on("error", (error) => {
        console.log(error);
        reject(error);
      });
      req.write(body);
      req.end();
    });
  }
  getUserAgentHeader() {
    if (typeof window !== "undefined") {
      return {};
    }
    return this.userAgentHeader;
  }
  /**
   *Converts keys in an object using a provided JSON mapper.
   * @param {any} obj - The object to convert keys for.
   * @param {Object} jsonMapper - The JSON mapper containing key mappings.
   * @returns {any} - The object with converted keys.
   */
  static convertKeysWithMapper(obj, jsonMapper) {
    if (!obj || typeof obj !== "object") {
      return obj;
    }
    if (Array.isArray(obj)) {
      return obj.map((item) => _HTTPLibrary.convertKeysWithMapper(item, jsonMapper));
    }
    const convertedObj = {};
    Object.entries(obj).forEach(([key, value]) => {
      if (value) {
        const convertedKey = jsonMapper.get(key) || key;
        convertedObj[convertedKey] = _HTTPLibrary.convertKeysWithMapper(value, jsonMapper);
      }
    });
    return convertedObj;
  }
};
var HTTPLibrary = _HTTPLibrary;
HTTPLibrary.responseMapper = /* @__PURE__ */ new Map([
  ["type", "type_"]
]);

// src/BaseService.ts
var BaseService = class {
  constructor(accessToken = "") {
    this.baseUrl = "https://api.doppler.com" /* DEFAULT */;
    this.httpClient = new HTTPLibrary();
    this.accessToken = "";
    this.accessTokenPrefix = "Bearer";
    this.setAccessToken(accessToken);
  }
  setAccessToken(accessToken) {
    this.accessToken = accessToken;
  }
  getAuthorizationHeader() {
    const accessTokenAuth = { Authorization: `${this.accessTokenPrefix} ${this.accessToken}` };
    return { ...accessTokenAuth };
  }
  setBaseUrl(url) {
    this.baseUrl = url;
  }
  static patternMatching(value, pattern, variableName) {
    if (!value) {
      throw new Error(`${variableName} cannot be null or undefined`);
    }
    if (!value.match(new RegExp(pattern))) {
      throw new Error(`Invalid value for ${variableName}: must match ${pattern}`);
    }
    return value;
  }
};
BaseService.urlEncode = (input) => Object.keys(input).map((key) => `${key}=${encodeURIComponent(input[key])}`).join("&");

// src/http/QuerySerializer.ts
var styleMethods = {
  simple: (value, explode) => {
    if (Array.isArray(value)) {
      return explode ? value.join(",") : value.join();
    }
    if (typeof value === "object" && value !== null) {
      if (explode) {
        return Object.entries(value).map(([parameterName, parameterValue]) => `${parameterName}=${parameterValue}`).join(",");
      }
      return Object.entries(value).flatMap(([parameterName, parameterValue]) => [parameterName, parameterValue]).join(",");
    }
    return String(value);
  },
  form: (parameterName, parameterValue, explode) => {
    if (Array.isArray(parameterValue)) {
      return explode ? parameterValue.map((parameterValue2) => `${parameterName}=${parameterValue2}`).join("&") : `${parameterName}=${parameterValue.join(",")}`;
    }
    if (typeof parameterValue === "object" && parameterValue !== null) {
      if (explode) {
        return Object.entries(parameterValue).map(([parameterName2, parameterValue2]) => `${parameterName2}=${parameterValue2}`).join("&");
      }
      return `${parameterName}=${Object.entries(parameterValue).flatMap(([parameterName2, parameterValue2]) => [parameterName2, parameterValue2]).join(",")}`;
    }
    return `${parameterName}=${parameterValue}`;
  }
};
function serializeQuery(style, explode, key, value) {
  const method = styleMethods[style];
  if (!method)
    return "";
  return method(key, value, explode);
}
function serializePath(style, explode, value, key) {
  const method = styleMethods[style];
  if (!method)
    return "";
  if (!key) {
    return method(value, explode);
  } else {
    return method(key, value, explode);
  }
}
function serializeHeader(explode, value) {
  if (!styleMethods.simple) {
    return "";
  }
  return styleMethods.simple(value, explode);
}

// src/services/projects/Projects.ts
var ProjectsService = class extends BaseService {
  /**
     * @summary List
     * @description Projects
  
     * @param optionalParams - Optional parameters
     * @param optionalParams.page - Page number
     * @param optionalParams.perPage - Items per page
     * @returns {Promise<ListResponse>} - The promise with the result
     */
  async list(optionalParams = {}) {
    const { page, perPage } = optionalParams;
    const queryParams = [];
    if (page) {
      queryParams.push(serializeQuery("form", true, "page", page));
    }
    if (perPage) {
      queryParams.push(serializeQuery("form", true, "per_page", perPage));
    }
    const urlEndpoint = "/v3/projects";
    const urlParams = queryParams.length > 0 ? `?${encodeURI(queryParams.join("&"))}` : "";
    const finalUrl = `${this.baseUrl + urlEndpoint}${urlParams}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Create
     * @description Project
  
     * @returns {Promise<CreateResponse>} - The promise with the result
     */
  async create(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/projects";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Retrieve
     * @description Project
  
     * @param project Unique identifier for the project object.
     * @returns {Promise<ProjectsGetResponse>} - The promise with the result
     */
  async get(project) {
    if (project === void 0) {
      throw new Error("The following parameter is required: project, cannot be empty or blank");
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    const urlEndpoint = "/v3/projects/project";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Update
     * @description Project
  
     * @returns {Promise<ProjectsUpdateResponse>} - The promise with the result
     */
  async update(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/projects/project";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Delete
     * @description Project
  
     * @returns {Promise<any>} - The promise with the result
     */
  async delete(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/projects/project";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.delete(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/secrets/Secrets.ts
var SecretsService = class extends BaseService {
  /**
     * @summary List
     * @description Secrets
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @param optionalParams - Optional parameters
     * @param optionalParams.accepts - Available options are: **application/json**, **text/plain**
     * @param optionalParams.includeDynamicSecrets - Whether or not to issue leases and include dynamic secret values for the config
     * @param optionalParams.dynamicSecretsTtlSec - The number of seconds until dynamic leases expire. Must be used with `include_dynamic_secrets`. Defaults to 1800 (30 minutes).
     * @param optionalParams.secrets - A comma-separated list of secrets to include in the response
     * @param optionalParams.includeManagedSecrets - Whether to include Doppler's auto-generated (managed) secrets
     * @returns {Promise<SecretsListResponse>} - The promise with the result
     */
  async list(project, config, optionalParams = {}) {
    const { accepts, includeDynamicSecrets, dynamicSecretsTtlSec, secrets, includeManagedSecrets } = optionalParams;
    if (project === void 0 || config === void 0) {
      throw new Error(
        "The following are required parameters: project,config, cannot be empty or blank"
      );
    }
    const queryParams = [];
    const headers = {};
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (config) {
      queryParams.push(serializeQuery("form", true, "config", config));
    }
    if (accepts) {
      headers["accepts"] = serializeHeader(false, accepts);
    }
    if (includeDynamicSecrets) {
      queryParams.push(
        serializeQuery("form", true, "include_dynamic_secrets", includeDynamicSecrets)
      );
    }
    if (dynamicSecretsTtlSec) {
      queryParams.push(
        serializeQuery("form", true, "dynamic_secrets_ttl_sec", dynamicSecretsTtlSec)
      );
    }
    if (secrets) {
      queryParams.push(serializeQuery("form", true, "secrets", secrets));
    }
    if (includeManagedSecrets) {
      queryParams.push(
        serializeQuery("form", true, "include_managed_secrets", includeManagedSecrets)
      );
    }
    const urlEndpoint = "/v3/configs/config/secrets";
    const urlParams = queryParams.length > 0 ? `?${encodeURI(queryParams.join("&"))}` : "";
    const finalUrl = `${this.baseUrl + urlEndpoint}${urlParams}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Update
     * @description Secrets
  
     * @returns {Promise<UpdateResponse>} - The promise with the result
     */
  async update(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/configs/config/secrets";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Retrieve
     * @description Secret
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @param name Name of the secret.
     * @returns {Promise<SecretsGetResponse>} - The promise with the result
     */
  async get(project, config, name) {
    if (project === void 0 || config === void 0 || name === void 0) {
      throw new Error(
        "The following are required parameters: project,config,name, cannot be empty or blank"
      );
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (config) {
      queryParams.push(serializeQuery("form", true, "config", config));
    }
    if (name) {
      queryParams.push(serializeQuery("form", true, "name", name));
    }
    const urlEndpoint = "/v3/configs/config/secret";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Delete
     * @description Secret
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @param name Name of the secret.
     * @returns {Promise<any>} - The promise with the result
     */
  async delete(project, config, name) {
    if (project === void 0 || config === void 0 || name === void 0) {
      throw new Error(
        "The following are required parameters: project,config,name, cannot be empty or blank"
      );
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (config) {
      queryParams.push(serializeQuery("form", true, "config", config));
    }
    if (name) {
      queryParams.push(serializeQuery("form", true, "name", name));
    }
    const urlEndpoint = "/v3/configs/config/secret";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.delete(
      finalUrl,
      { project, config, name },
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Download
     * @description Download Secrets
  
     * @param project Unique identifier for the project object. Not required if using a Service Token.
     * @param config Name of the config object. Not required if using a Service Token.
     * @param optionalParams - Optional parameters
     * @param optionalParams.format - Needed input variable
     * @param optionalParams.nameTransformer - Transform secret names to a different case
     * @param optionalParams.includeDynamicSecrets - Whether or not to issue leases and include dynamic secret values for the config
     * @param optionalParams.dynamicSecretsTtlSec - The number of seconds until dynamic leases expire. Must be used with `include_dynamic_secrets`. Defaults to 1800 (30 minutes).
     * @returns {Promise<DownloadResponse>} - The promise with the result
     */
  async download(project, config, optionalParams = {}) {
    const { format, nameTransformer, includeDynamicSecrets, dynamicSecretsTtlSec } = optionalParams;
    if (project === void 0 || config === void 0) {
      throw new Error(
        "The following are required parameters: project,config, cannot be empty or blank"
      );
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (config) {
      queryParams.push(serializeQuery("form", true, "config", config));
    }
    if (format) {
      queryParams.push(serializeQuery("form", true, "format", format));
    }
    if (nameTransformer) {
      queryParams.push(serializeQuery("form", true, "name_transformer", nameTransformer));
    }
    if (includeDynamicSecrets) {
      queryParams.push(
        serializeQuery("form", true, "include_dynamic_secrets", includeDynamicSecrets)
      );
    }
    if (dynamicSecretsTtlSec) {
      queryParams.push(
        serializeQuery("form", true, "dynamic_secrets_ttl_sec", dynamicSecretsTtlSec)
      );
    }
    const urlEndpoint = "/v3/configs/config/secrets/download";
    const urlParams = queryParams.length > 0 ? `?${encodeURI(queryParams.join("&"))}` : "";
    const finalUrl = `${this.baseUrl + urlEndpoint}${urlParams}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary List Names
     * @description Secret Names
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @param optionalParams - Optional parameters
     * @param optionalParams.includeDynamicSecrets - Whether or not to issue leases and include dynamic secret values for the config
     * @param optionalParams.includeManagedSecrets - Whether to include Doppler's auto-generated (managed) secrets
     * @returns {Promise<NamesResponse>} - The promise with the result
     */
  async names(project, config, optionalParams = {}) {
    const { includeDynamicSecrets, includeManagedSecrets } = optionalParams;
    if (project === void 0 || config === void 0) {
      throw new Error(
        "The following are required parameters: project,config, cannot be empty or blank"
      );
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (config) {
      queryParams.push(serializeQuery("form", true, "config", config));
    }
    if (includeDynamicSecrets) {
      queryParams.push(
        serializeQuery("form", true, "include_dynamic_secrets", includeDynamicSecrets)
      );
    }
    if (includeManagedSecrets) {
      queryParams.push(
        serializeQuery("form", true, "include_managed_secrets", includeManagedSecrets)
      );
    }
    const urlEndpoint = "/v3/configs/config/secrets/names";
    const urlParams = queryParams.length > 0 ? `?${encodeURI(queryParams.join("&"))}` : "";
    const finalUrl = `${this.baseUrl + urlEndpoint}${urlParams}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Update Note
     * @description Set a note on a secret
  
     * @returns {Promise<UpdateNoteResponse>} - The promise with the result
     */
  async updateNote(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/configs/config/secrets/note";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/configLogs/ConfigLogs.ts
var ConfigLogsService = class extends BaseService {
  /**
     * @summary List
     * @description Config Logs
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @param optionalParams - Optional parameters
     * @param optionalParams.page - Page number
     * @param optionalParams.perPage - Items per page
     * @returns {Promise<ConfigLogsListResponse>} - The promise with the result
     */
  async list(project, config, optionalParams = {}) {
    const { page, perPage } = optionalParams;
    if (project === void 0 || config === void 0) {
      throw new Error(
        "The following are required parameters: project,config, cannot be empty or blank"
      );
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (config) {
      queryParams.push(serializeQuery("form", true, "config", config));
    }
    if (page) {
      queryParams.push(serializeQuery("form", true, "page", page));
    }
    if (perPage) {
      queryParams.push(serializeQuery("form", true, "per_page", perPage));
    }
    const urlEndpoint = "/v3/configs/config/logs";
    const urlParams = queryParams.length > 0 ? `?${encodeURI(queryParams.join("&"))}` : "";
    const finalUrl = `${this.baseUrl + urlEndpoint}${urlParams}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Retrieve
     * @description Config Log
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @param log Unique identifier for the log object.
     * @returns {Promise<GetResponse>} - The promise with the result
     */
  async get(project, config, log) {
    if (project === void 0 || config === void 0 || log === void 0) {
      throw new Error(
        "The following are required parameters: project,config,log, cannot be empty or blank"
      );
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (config) {
      queryParams.push(serializeQuery("form", true, "config", config));
    }
    if (log) {
      queryParams.push(serializeQuery("form", true, "log", log));
    }
    const urlEndpoint = "/v3/configs/config/logs/log";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Rollback
     * @description Config Log
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @param log Unique identifier for the log object.
     * @returns {Promise<RollbackResponse>} - The promise with the result
     */
  async rollback(project, config, log) {
    if (project === void 0 || config === void 0 || log === void 0) {
      throw new Error(
        "The following are required parameters: project,config,log, cannot be empty or blank"
      );
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (config) {
      queryParams.push(serializeQuery("form", true, "config", config));
    }
    if (log) {
      queryParams.push(serializeQuery("form", true, "log", log));
    }
    const urlEndpoint = "/v3/configs/config/logs/log/rollback";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.post(
      finalUrl,
      { project, config, log },
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/environments/Environments.ts
var EnvironmentsService = class extends BaseService {
  /**
     * @summary Retrieve
     * @description Environment
  
     * @param project The project's name
     * @param environment The environment's slug
     * @returns {Promise<EnvironmentsGetResponse>} - The promise with the result
     */
  async get(project, environment) {
    if (project === void 0 || environment === void 0) {
      throw new Error(
        "The following are required parameters: project,environment, cannot be empty or blank"
      );
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (environment) {
      queryParams.push(serializeQuery("form", true, "environment", environment));
    }
    const urlEndpoint = "/v3/environments/environment";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Rename
     * @description Environment
  
     * @param project The project's name
     * @param environment The environment's slug
     * @returns {Promise<RenameResponse>} - The promise with the result
     */
  async rename(input, project, environment) {
    if (project === void 0 || environment === void 0) {
      throw new Error(
        "The following are required parameters: project,environment, cannot be empty or blank"
      );
    }
    const queryParams = [];
    const headers = { "Content-type": "application/json" };
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (environment) {
      queryParams.push(serializeQuery("form", true, "environment", environment));
    }
    const urlEndpoint = "/v3/environments/environment";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.put(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Delete
     * @description Environment
  
     * @param project The project's name
     * @param environment The environment's slug
     * @returns {Promise<any>} - The promise with the result
     */
  async delete(project, environment) {
    if (project === void 0 || environment === void 0) {
      throw new Error(
        "The following are required parameters: project,environment, cannot be empty or blank"
      );
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (environment) {
      queryParams.push(serializeQuery("form", true, "environment", environment));
    }
    const urlEndpoint = "/v3/environments/environment";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.delete(
      finalUrl,
      { project, environment },
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary List
     * @description Environments
  
     * @param project The project's name
     * @returns {Promise<EnvironmentsListResponse>} - The promise with the result
     */
  async list(project) {
    if (project === void 0) {
      throw new Error("The following parameter is required: project, cannot be empty or blank");
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    const urlEndpoint = "/v3/environments";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Create
     * @description Environment
  
     * @param project The project's name
     * @returns {Promise<EnvironmentsCreateResponse>} - The promise with the result
     */
  async create(input, project) {
    if (project === void 0) {
      throw new Error("The following parameter is required: project, cannot be empty or blank");
    }
    const queryParams = [];
    const headers = { "Content-type": "application/json" };
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    const urlEndpoint = "/v3/environments";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/configs/Configs.ts
var ConfigsService = class extends BaseService {
  /**
     * @summary List
     * @description Fetch all configs.
  
     * @param project The project's name
     * @param optionalParams - Optional parameters
     * @param optionalParams.environment - (optional) the environment from which to list configs
     * @param optionalParams.page - Page number
     * @param optionalParams.perPage - Items per page
     * @returns {Promise<ConfigsListResponse>} - The promise with the result
     */
  async list(project, optionalParams = {}) {
    const { environment, page, perPage } = optionalParams;
    if (project === void 0) {
      throw new Error("The following parameter is required: project, cannot be empty or blank");
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (environment) {
      queryParams.push(serializeQuery("form", true, "environment", environment));
    }
    if (page) {
      queryParams.push(serializeQuery("form", true, "page", page));
    }
    if (perPage) {
      queryParams.push(serializeQuery("form", true, "per_page", perPage));
    }
    const urlEndpoint = "/v3/configs";
    const urlParams = queryParams.length > 0 ? `?${encodeURI(queryParams.join("&"))}` : "";
    const finalUrl = `${this.baseUrl + urlEndpoint}${urlParams}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Create
     * @description Create a new branch config.
  
     * @returns {Promise<ConfigsCreateResponse>} - The promise with the result
     */
  async create(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/configs";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Retrieve
     * @description Fetch a config's details.
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @returns {Promise<ConfigsGetResponse>} - The promise with the result
     */
  async get(project, config) {
    if (project === void 0 || config === void 0) {
      throw new Error(
        "The following are required parameters: project,config, cannot be empty or blank"
      );
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (config) {
      queryParams.push(serializeQuery("form", true, "config", config));
    }
    const urlEndpoint = "/v3/configs/config";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Update
     * @description Modify an existing config.
  
     * @returns {Promise<ConfigsUpdateResponse>} - The promise with the result
     */
  async update(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/configs/config";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Delete
     * @description Permanently delete the config.
  
     * @returns {Promise<DeleteResponse>} - The promise with the result
     */
  async delete(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/configs/config";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.delete(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Clone
     * @description Create a new branch config by cloning another. This duplicates a branch config and all its secrets.
  
     * @returns {Promise<CloneResponse>} - The promise with the result
     */
  async clone(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/configs/config/clone";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Lock
     * @description Prevent the config from being renamed or deleted.
  
     * @returns {Promise<LockResponse>} - The promise with the result
     */
  async lock(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/configs/config/lock";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Unlock
     * @description Allow the config to be renamed and/or deleted.
  
     * @returns {Promise<UnlockResponse>} - The promise with the result
     */
  async unlock(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/configs/config/unlock";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary List
  
     * @param project Needed input variable
     * @param config Needed input variable
     * @returns {Promise<ListTrustedIpsResponse>} - The promise with the result
     */
  async listTrustedIps(project, config) {
    if (project === void 0 || config === void 0) {
      throw new Error(
        "The following are required parameters: project,config, cannot be empty or blank"
      );
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (config) {
      queryParams.push(serializeQuery("form", true, "config", config));
    }
    const urlEndpoint = "/v3/configs/config/trusted_ips";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Add
  
     * @param project Needed input variable
     * @param config Needed input variable
     * @returns {Promise<AddTrustedIpResponse>} - The promise with the result
     */
  async addTrustedIp(input, project, config) {
    if (project === void 0 || config === void 0) {
      throw new Error(
        "The following are required parameters: project,config, cannot be empty or blank"
      );
    }
    const queryParams = [];
    const headers = { "Content-type": "application/json" };
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (config) {
      queryParams.push(serializeQuery("form", true, "config", config));
    }
    const urlEndpoint = "/v3/configs/config/trusted_ips";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Delete
  
     * @param project Needed input variable
     * @param config Needed input variable
     * @returns {Promise<any>} - The promise with the result
     */
  async deleteTrustedIp(input, project, config) {
    if (project === void 0 || config === void 0) {
      throw new Error(
        "The following are required parameters: project,config, cannot be empty or blank"
      );
    }
    const queryParams = [];
    const headers = { "Content-type": "application/json" };
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (config) {
      queryParams.push(serializeQuery("form", true, "config", config));
    }
    const urlEndpoint = "/v3/configs/config/trusted_ips";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.delete(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/activityLogs/ActivityLogs.ts
var ActivityLogsService = class extends BaseService {
  /**
     * @summary Retrieve
     * @description Activity Log
  
     * @param log Unique identifier for the log object.
     * @returns {Promise<RetrieveResponse>} - The promise with the result
     */
  async retrieve(log) {
    if (log === void 0) {
      throw new Error("The following parameter is required: log, cannot be empty or blank");
    }
    const queryParams = [];
    if (log) {
      queryParams.push(serializeQuery("form", true, "log", log));
    }
    const urlEndpoint = "/v3/logs/log";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary List
     * @description Activity Logs
  
     * @param optionalParams - Optional parameters
     * @param optionalParams.page - Page number
     * @param optionalParams.perPage - Items per page
     * @returns {Promise<ActivityLogsListResponse>} - The promise with the result
     */
  async list(optionalParams = {}) {
    const { page, perPage } = optionalParams;
    const queryParams = [];
    if (page) {
      queryParams.push(serializeQuery("form", true, "page", page));
    }
    if (perPage) {
      queryParams.push(serializeQuery("form", true, "per_page", perPage));
    }
    const urlEndpoint = "/v3/logs";
    const urlParams = queryParams.length > 0 ? `?${encodeURI(queryParams.join("&"))}` : "";
    const finalUrl = `${this.baseUrl + urlEndpoint}${urlParams}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/workplace/Workplace.ts
var WorkplaceService = class extends BaseService {
  /**
     * @summary Retrieve
  
     * @returns {Promise<WorkplaceGetResponse>} - The promise with the result
     */
  async get() {
    const urlEndpoint = "/v3/workplace";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Update
  
     * @returns {Promise<WorkplaceUpdateResponse>} - The promise with the result
     */
  async update(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/workplace";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/serviceTokens/ServiceTokens.ts
var ServiceTokensService = class extends BaseService {
  /**
     * @summary List
     * @description Service Tokens
  
     * @param project Unique identifier for the project object.
     * @param config Name of the config object.
     * @returns {Promise<ServiceTokensListResponse>} - The promise with the result
     */
  async list(project, config) {
    if (project === void 0 || config === void 0) {
      throw new Error(
        "The following are required parameters: project,config, cannot be empty or blank"
      );
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (config) {
      queryParams.push(serializeQuery("form", true, "config", config));
    }
    const urlEndpoint = "/v3/configs/config/tokens";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Create
     * @description Service Token
  
     * @returns {Promise<ServiceTokensCreateResponse>} - The promise with the result
     */
  async create(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/configs/config/tokens";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Delete
     * @description Service Token
  
     * @returns {Promise<DeleteResponse>} - The promise with the result
     */
  async delete(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/configs/config/tokens/token";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.delete(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/audit/Audit.ts
var AuditService = class extends BaseService {
  /**
     * @summary Workplace User
     * @description Get a specific user in a workplace
  
     * @param workplaceUserId The ID of the workplace user
     * @param optionalParams - Optional parameters
     * @param optionalParams.settings - If true, the api will return more information if the user has e.g. SAML enabled and/or Multi Factor Auth enabled
     * @returns {Promise<GetUserResponse>} - The promise with the result
     */
  async getUser(workplaceUserId, optionalParams = {}) {
    const { settings } = optionalParams;
    if (workplaceUserId === void 0) {
      throw new Error(
        "The following parameter is required: workplaceUserId, cannot be empty or blank"
      );
    }
    const queryParams = [];
    let urlEndpoint = "/v3/workplace/users/{workplace_user_id}";
    urlEndpoint = urlEndpoint.replace(
      "{workplace_user_id}",
      encodeURIComponent(serializePath("simple", false, workplaceUserId, void 0))
    );
    if (settings) {
      queryParams.push(serializeQuery("form", true, "settings", settings));
    }
    const urlParams = queryParams.length > 0 ? `?${encodeURI(queryParams.join("&"))}` : "";
    const finalUrl = `${this.baseUrl + urlEndpoint}${urlParams}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/dynamicSecrets/DynamicSecrets.ts
var DynamicSecretsService = class extends BaseService {
  /**
     * @summary Issue Lease
     * @description Issue a lease for a dynamic secret
  
     * @returns {Promise<IssueLeaseResponse>} - The promise with the result
     */
  async issueLease(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/configs/config/dynamic_secrets/dynamic_secret/leases";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Revoke Lease
  
     * @returns {Promise<RevokeLeaseResponse>} - The promise with the result
     */
  async revokeLease(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/configs/config/dynamic_secrets/dynamic_secret/leases/lease";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.delete(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/auth/Auth.ts
var AuthService = class extends BaseService {
  /**
     * @summary Revoke
     * @description Revoke an auth token
  
     * @returns {Promise<any>} - The promise with the result
     */
  async revoke(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/auth/revoke";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Me
     * @description Get information about a token
  
     * @returns {Promise<MeResponse>} - The promise with the result
     */
  async me() {
    const urlEndpoint = "/v3/me";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/integrations/Integrations.ts
var IntegrationsService = class extends BaseService {
  /**
     * @summary List
     * @description List all existing integrations
  
     * @returns {Promise<IntegrationsListResponse>} - The promise with the result
     */
  async list() {
    const urlEndpoint = "/v3/integrations";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Create
     * @description Create a new external integration.
  
     * @returns {Promise<IntegrationsCreateResponse>} - The promise with the result
     */
  async create(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/integrations";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Retrieve
     * @description Retrieve an existing integration
  
     * @param integration The integration slug
     * @returns {Promise<IntegrationsGetResponse>} - The promise with the result
     */
  async get(integration) {
    if (integration === void 0) {
      throw new Error("The following parameter is required: integration, cannot be empty or blank");
    }
    const queryParams = [];
    if (integration) {
      queryParams.push(serializeQuery("form", true, "integration", integration));
    }
    const urlEndpoint = "/v3/integrations/integration";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Update
     * @description Update an existing integration.
  
     * @param integration The slug of the integration to update
     * @returns {Promise<IntegrationsUpdateResponse>} - The promise with the result
     */
  async update(input, integration) {
    if (integration === void 0) {
      throw new Error("The following parameter is required: integration, cannot be empty or blank");
    }
    const queryParams = [];
    const headers = { "Content-type": "application/json" };
    if (integration) {
      queryParams.push(serializeQuery("form", true, "integration", integration));
    }
    const urlEndpoint = "/v3/integrations/integration";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.put(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Delete
     * @description Delete an existing integration.
  
     * @param integration The slug of the integration to delete
     * @returns {Promise<IntegrationsDeleteResponse>} - The promise with the result
     */
  async delete(integration) {
    if (integration === void 0) {
      throw new Error("The following parameter is required: integration, cannot be empty or blank");
    }
    const queryParams = [];
    if (integration) {
      queryParams.push(serializeQuery("form", true, "integration", integration));
    }
    const urlEndpoint = "/v3/integrations/integration";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.delete(
      finalUrl,
      { integration },
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/syncs/Syncs.ts
var SyncsService = class extends BaseService {
  /**
     * @summary Create
     * @description Create a new secrets sync.
  
     * @param project The project slug
     * @param config The config slug
     * @returns {Promise<SyncsCreateResponse>} - The promise with the result
     */
  async create(input, project, config) {
    if (project === void 0 || config === void 0) {
      throw new Error(
        "The following are required parameters: project,config, cannot be empty or blank"
      );
    }
    const queryParams = [];
    const headers = { "Content-type": "application/json" };
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (config) {
      queryParams.push(serializeQuery("form", true, "config", config));
    }
    const urlEndpoint = "/v3/configs/config/syncs";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Retrieve
     * @description Retrieve an existing secrets sync.
  
     * @param project The project slug
     * @param config The config slug
     * @param sync The sync slug
     * @returns {Promise<SyncsGetResponse>} - The promise with the result
     */
  async get(project, config, sync) {
    if (project === void 0 || config === void 0 || sync === void 0) {
      throw new Error(
        "The following are required parameters: project,config,sync, cannot be empty or blank"
      );
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (config) {
      queryParams.push(serializeQuery("form", true, "config", config));
    }
    if (sync) {
      queryParams.push(serializeQuery("form", true, "sync", sync));
    }
    const urlEndpoint = "/v3/configs/config/syncs/sync";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Delete
     * @description Delete an existing sync.
  
     * @param project The project slug
     * @param config The config slug
     * @param sync The sync slug
     * @param deleteFromTarget Whether or not to delete the synced data from the target integration
     * @returns {Promise<SyncsDeleteResponse>} - The promise with the result
     */
  async delete(project, config, sync, deleteFromTarget) {
    if (project === void 0 || config === void 0 || sync === void 0 || deleteFromTarget === void 0) {
      throw new Error(
        "The following are required parameters: project,config,sync,deleteFromTarget, cannot be empty or blank"
      );
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (config) {
      queryParams.push(serializeQuery("form", true, "config", config));
    }
    if (sync) {
      queryParams.push(serializeQuery("form", true, "sync", sync));
    }
    if (deleteFromTarget) {
      queryParams.push(serializeQuery("form", true, "delete_from_target", deleteFromTarget));
    }
    const urlEndpoint = "/v3/configs/config/syncs/sync";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.delete(
      finalUrl,
      { project, config, sync, delete_from_target: deleteFromTarget },
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/workplaceRoles/WorkplaceRoles.ts
var WorkplaceRolesService = class extends BaseService {
  /**
     * @summary List
  
     * @returns {Promise<WorkplaceRolesListResponse>} - The promise with the result
     */
  async list() {
    const urlEndpoint = "/v3/workplace/roles";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Create
  
     * @returns {Promise<WorkplaceRolesCreateResponse>} - The promise with the result
     */
  async create() {
    const urlEndpoint = "/v3/workplace/roles";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary List Permissions
  
     * @returns {Promise<ListPermissionsResponse>} - The promise with the result
     */
  async listPermissions() {
    const urlEndpoint = "/v3/workplace/permissions";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Retrieve
  
     * @param role The role's unique identifier
     * @returns {Promise<WorkplaceRolesGetResponse>} - The promise with the result
     */
  async get(role) {
    if (role === void 0) {
      throw new Error("The following parameter is required: role, cannot be empty or blank");
    }
    let urlEndpoint = "/v3/workplace/roles/role/{role}";
    urlEndpoint = urlEndpoint.replace(
      "{role}",
      encodeURIComponent(serializePath("simple", false, role, void 0))
    );
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Update
  
     * @param role The role's unique identifier
     * @returns {Promise<WorkplaceRolesUpdateResponse>} - The promise with the result
     */
  async update(role) {
    if (role === void 0) {
      throw new Error("The following parameter is required: role, cannot be empty or blank");
    }
    let urlEndpoint = "/v3/workplace/roles/role/{role}";
    urlEndpoint = urlEndpoint.replace(
      "{role}",
      encodeURIComponent(serializePath("simple", false, role, void 0))
    );
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.patch(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Delete
  
     * @param role The role's unique identifier
     * @returns {Promise<any>} - The promise with the result
     */
  async delete(role) {
    if (role === void 0) {
      throw new Error("The following parameter is required: role, cannot be empty or blank");
    }
    let urlEndpoint = "/v3/workplace/roles/role/{role}";
    urlEndpoint = urlEndpoint.replace(
      "{role}",
      encodeURIComponent(serializePath("simple", false, role, void 0))
    );
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.delete(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/projectRoles/ProjectRoles.ts
var ProjectRolesService = class extends BaseService {
  /**
     * @summary List
  
     * @returns {Promise<ProjectRolesListResponse>} - The promise with the result
     */
  async list() {
    const urlEndpoint = "/v3/projects/roles";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Create
  
     * @returns {Promise<ProjectRolesCreateResponse>} - The promise with the result
     */
  async create() {
    const urlEndpoint = "/v3/projects/roles";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Retrieve
  
     * @param role The role's unique identifier
     * @returns {Promise<ProjectRolesGetResponse>} - The promise with the result
     */
  async get(role) {
    if (role === void 0) {
      throw new Error("The following parameter is required: role, cannot be empty or blank");
    }
    let urlEndpoint = "/v3/projects/roles/role/{role}";
    urlEndpoint = urlEndpoint.replace(
      "{role}",
      encodeURIComponent(serializePath("simple", false, role, void 0))
    );
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Update
  
     * @param role The role's unique identifier
     * @returns {Promise<ProjectRolesUpdateResponse>} - The promise with the result
     */
  async update(role) {
    if (role === void 0) {
      throw new Error("The following parameter is required: role, cannot be empty or blank");
    }
    let urlEndpoint = "/v3/projects/roles/role/{role}";
    urlEndpoint = urlEndpoint.replace(
      "{role}",
      encodeURIComponent(serializePath("simple", false, role, void 0))
    );
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.patch(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Delete
  
     * @param role The role's unique identifier
     * @returns {Promise<any>} - The promise with the result
     */
  async delete(role) {
    if (role === void 0) {
      throw new Error("The following parameter is required: role, cannot be empty or blank");
    }
    let urlEndpoint = "/v3/projects/roles/role/{role}";
    urlEndpoint = urlEndpoint.replace(
      "{role}",
      encodeURIComponent(serializePath("simple", false, role, void 0))
    );
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.delete(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary List Permissions
  
     * @returns {Promise<ProjectRolesListPermissionsResponse>} - The promise with the result
     */
  async listPermissions() {
    const urlEndpoint = "/v3/projects/permissions";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/projectMembers/ProjectMembers.ts
var ProjectMembersService = class extends BaseService {
  /**
     * @summary List
  
     * @param project Project slug
     * @param optionalParams - Optional parameters
     * @param optionalParams.page - Needed input variable
     * @param optionalParams.perPage - Needed input variable
     * @returns {Promise<ProjectMembersListResponse>} - The promise with the result
     */
  async list(project, optionalParams = {}) {
    const { page, perPage } = optionalParams;
    if (project === void 0) {
      throw new Error("The following parameter is required: project, cannot be empty or blank");
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    if (page) {
      queryParams.push(serializeQuery("form", true, "page", page));
    }
    if (perPage) {
      queryParams.push(serializeQuery("form", true, "per_page", perPage));
    }
    const urlEndpoint = "/v3/projects/project/members";
    const urlParams = queryParams.length > 0 ? `?${encodeURI(queryParams.join("&"))}` : "";
    const finalUrl = `${this.baseUrl + urlEndpoint}${urlParams}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Add
  
     * @param project Project slug
     * @returns {Promise<AddResponse>} - The promise with the result
     */
  async add(input, project) {
    if (project === void 0) {
      throw new Error("The following parameter is required: project, cannot be empty or blank");
    }
    const queryParams = [];
    const headers = { "Content-type": "application/json" };
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    const urlEndpoint = "/v3/projects/project/members";
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Retrieve
  
     * @param project Project slug
     * @param type_ Needed input variable
     * @param slug Member's slug
     * @returns {Promise<ProjectMembersGetResponse>} - The promise with the result
     */
  async get(project, type, slug) {
    if (project === void 0 || type === void 0 || slug === void 0) {
      throw new Error(
        "The following are required parameters: project,type,slug, cannot be empty or blank"
      );
    }
    const queryParams = [];
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    let urlEndpoint = "/v3/projects/project/members/member/{type}/{slug}";
    urlEndpoint = urlEndpoint.replace(
      "{type_}",
      encodeURIComponent(serializePath("simple", false, type, void 0))
    );
    urlEndpoint = urlEndpoint.replace(
      "{slug}",
      encodeURIComponent(serializePath("simple", false, slug, void 0))
    );
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Update
  
     * @param type_ Needed input variable
     * @param slug Member's slug
     * @param project Project slug
     * @returns {Promise<ProjectMembersUpdateResponse>} - The promise with the result
     */
  async update(input, type, slug, project) {
    if (type === void 0 || slug === void 0 || project === void 0) {
      throw new Error(
        "The following are required parameters: type,slug,project, cannot be empty or blank"
      );
    }
    const queryParams = [];
    const headers = { "Content-type": "application/json" };
    let urlEndpoint = "/v3/projects/project/members/member/{type}/{slug}";
    urlEndpoint = urlEndpoint.replace(
      "{type_}",
      encodeURIComponent(serializePath("simple", false, type, void 0))
    );
    urlEndpoint = urlEndpoint.replace(
      "{slug}",
      encodeURIComponent(serializePath("simple", false, slug, void 0))
    );
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.patch(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Delete
  
     * @param type_ Needed input variable
     * @param slug Member's slug
     * @param project Project slug
     * @returns {Promise<any>} - The promise with the result
     */
  async delete(type, slug, project) {
    if (type === void 0 || slug === void 0 || project === void 0) {
      throw new Error(
        "The following are required parameters: type,slug,project, cannot be empty or blank"
      );
    }
    const queryParams = [];
    let urlEndpoint = "/v3/projects/project/members/member/{type}/{slug}";
    urlEndpoint = urlEndpoint.replace(
      "{type_}",
      encodeURIComponent(serializePath("simple", false, type, void 0))
    );
    urlEndpoint = urlEndpoint.replace(
      "{slug}",
      encodeURIComponent(serializePath("simple", false, slug, void 0))
    );
    if (project) {
      queryParams.push(serializeQuery("form", true, "project", project));
    }
    const finalUrl = `${this.baseUrl + urlEndpoint}?${encodeURI(queryParams.join("&"))}`;
    const response = await this.httpClient.delete(
      finalUrl,
      { project },
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/invites/Invites.ts
var InvitesService = class extends BaseService {
  /**
     * @summary List
  
     * @param optionalParams - Optional parameters
     * @param optionalParams.page - Needed input variable
     * @param optionalParams.perPage - Needed input variable
     * @returns {Promise<InvitesListResponse>} - The promise with the result
     */
  async list(optionalParams = {}) {
    const { page, perPage } = optionalParams;
    const queryParams = [];
    if (page) {
      queryParams.push(serializeQuery("form", true, "page", page));
    }
    if (perPage) {
      queryParams.push(serializeQuery("form", true, "per_page", perPage));
    }
    const urlEndpoint = "/v3/workplace/invites";
    const urlParams = queryParams.length > 0 ? `?${encodeURI(queryParams.join("&"))}` : "";
    const finalUrl = `${this.baseUrl + urlEndpoint}${urlParams}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/serviceAccounts/ServiceAccounts.ts
var ServiceAccountsService = class extends BaseService {
  /**
     * @summary List
  
     * @param optionalParams - Optional parameters
     * @param optionalParams.page - Needed input variable
     * @param optionalParams.perPage - Needed input variable
     * @returns {Promise<ServiceAccountsListResponse>} - The promise with the result
     */
  async list(optionalParams = {}) {
    const { page, perPage } = optionalParams;
    const queryParams = [];
    if (page) {
      queryParams.push(serializeQuery("form", true, "page", page));
    }
    if (perPage) {
      queryParams.push(serializeQuery("form", true, "per_page", perPage));
    }
    const urlEndpoint = "/v3/workplace/service_accounts";
    const urlParams = queryParams.length > 0 ? `?${encodeURI(queryParams.join("&"))}` : "";
    const finalUrl = `${this.baseUrl + urlEndpoint}${urlParams}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Create
  
     * @returns {Promise<ServiceAccountsCreateResponse>} - The promise with the result
     */
  async create(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/workplace/service_accounts";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Retrieve
  
     * @param slug Slug of the service account
     * @returns {Promise<ServiceAccountsGetResponse>} - The promise with the result
     */
  async get(slug) {
    if (slug === void 0) {
      throw new Error("The following parameter is required: slug, cannot be empty or blank");
    }
    let urlEndpoint = "/v3/workplace/service_accounts/service_account/{slug}";
    urlEndpoint = urlEndpoint.replace(
      "{slug}",
      encodeURIComponent(serializePath("simple", false, slug, void 0))
    );
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Update
  
     * @param slug Slug of the service account
     * @returns {Promise<ServiceAccountsUpdateResponse>} - The promise with the result
     */
  async update(input, slug) {
    if (slug === void 0) {
      throw new Error("The following parameter is required: slug, cannot be empty or blank");
    }
    const headers = { "Content-type": "application/json" };
    let urlEndpoint = "/v3/workplace/service_accounts/service_account/{slug}";
    urlEndpoint = urlEndpoint.replace(
      "{slug}",
      encodeURIComponent(serializePath("simple", false, slug, void 0))
    );
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.patch(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Delete
  
     * @param slug Slug of the service account
     * @returns {Promise<any>} - The promise with the result
     */
  async delete(slug) {
    if (slug === void 0) {
      throw new Error("The following parameter is required: slug, cannot be empty or blank");
    }
    let urlEndpoint = "/v3/workplace/service_accounts/service_account/{slug}";
    urlEndpoint = urlEndpoint.replace(
      "{slug}",
      encodeURIComponent(serializePath("simple", false, slug, void 0))
    );
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.delete(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/groups/Groups.ts
var GroupsService = class extends BaseService {
  /**
     * @summary List
  
     * @param optionalParams - Optional parameters
     * @param optionalParams.page - Needed input variable
     * @param optionalParams.perPage - Needed input variable
     * @returns {Promise<GroupsListResponse>} - The promise with the result
     */
  async list(optionalParams = {}) {
    const { page, perPage } = optionalParams;
    const queryParams = [];
    if (page) {
      queryParams.push(serializeQuery("form", true, "page", page));
    }
    if (perPage) {
      queryParams.push(serializeQuery("form", true, "per_page", perPage));
    }
    const urlEndpoint = "/v3/workplace/groups";
    const urlParams = queryParams.length > 0 ? `?${encodeURI(queryParams.join("&"))}` : "";
    const finalUrl = `${this.baseUrl + urlEndpoint}${urlParams}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Create
  
     * @returns {Promise<GroupsCreateResponse>} - The promise with the result
     */
  async create(input) {
    const headers = { "Content-type": "application/json" };
    const urlEndpoint = "/v3/workplace/groups";
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Retrieve
  
     * @param slug The group's slug
     * @returns {Promise<GroupsGetResponse>} - The promise with the result
     */
  async get(slug) {
    if (slug === void 0) {
      throw new Error("The following parameter is required: slug, cannot be empty or blank");
    }
    let urlEndpoint = "/v3/workplace/groups/group/{slug}";
    urlEndpoint = urlEndpoint.replace(
      "{slug}",
      encodeURIComponent(serializePath("simple", false, slug, void 0))
    );
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Update
  
     * @param slug The group's slug
     * @returns {Promise<GroupsUpdateResponse>} - The promise with the result
     */
  async update(input, slug) {
    if (slug === void 0) {
      throw new Error("The following parameter is required: slug, cannot be empty or blank");
    }
    const headers = { "Content-type": "application/json" };
    let urlEndpoint = "/v3/workplace/groups/group/{slug}";
    urlEndpoint = urlEndpoint.replace(
      "{slug}",
      encodeURIComponent(serializePath("simple", false, slug, void 0))
    );
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.patch(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Delete
  
     * @param slug The group's slug
     * @returns {Promise<any>} - The promise with the result
     */
  async delete(slug) {
    if (slug === void 0) {
      throw new Error("The following parameter is required: slug, cannot be empty or blank");
    }
    let urlEndpoint = "/v3/workplace/groups/group/{slug}";
    urlEndpoint = urlEndpoint.replace(
      "{slug}",
      encodeURIComponent(serializePath("simple", false, slug, void 0))
    );
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.delete(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Add Member
  
     * @param slug The group's slug
     * @returns {Promise<any>} - The promise with the result
     */
  async addMember(input, slug) {
    if (slug === void 0) {
      throw new Error("The following parameter is required: slug, cannot be empty or blank");
    }
    const headers = { "Content-type": "application/json" };
    let urlEndpoint = "/v3/workplace/groups/group/{slug}/members";
    urlEndpoint = urlEndpoint.replace(
      "{slug}",
      encodeURIComponent(serializePath("simple", false, slug, void 0))
    );
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.post(
      finalUrl,
      input,
      {
        ...headers,
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Delete Member
  
     * @param slug The group's slug
     * @param type_ Needed input variable
     * @param memberSlug The member's slug
     * @returns {Promise<any>} - The promise with the result
     */
  async deleteMember(slug, type, memberSlug) {
    if (slug === void 0 || type === void 0 || memberSlug === void 0) {
      throw new Error(
        "The following are required parameters: slug,type,memberSlug, cannot be empty or blank"
      );
    }
    let urlEndpoint = "/v3/workplace/groups/group/{slug}/members/{type}/{member_slug}";
    urlEndpoint = urlEndpoint.replace(
      "{slug}",
      encodeURIComponent(serializePath("simple", false, slug, void 0))
    );
    urlEndpoint = urlEndpoint.replace(
      "{type_}",
      encodeURIComponent(serializePath("simple", false, type, void 0))
    );
    urlEndpoint = urlEndpoint.replace(
      "{member_slug}",
      encodeURIComponent(serializePath("simple", false, memberSlug, void 0))
    );
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.delete(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/users/Users.ts
var UsersService = class extends BaseService {
  /**
     * @summary List
     * @description Get all users within a workplace
  
     * @param optionalParams - Optional parameters
     * @param optionalParams.page - The page of users to fetch
     * @returns {Promise<UsersListResponse>} - The promise with the result
     */
  async list(optionalParams = {}) {
    const { page } = optionalParams;
    const queryParams = [];
    if (page) {
      queryParams.push(serializeQuery("form", true, "page", page));
    }
    const urlEndpoint = "/v3/workplace/users";
    const urlParams = queryParams.length > 0 ? `?${encodeURI(queryParams.join("&"))}` : "";
    const finalUrl = `${this.baseUrl + urlEndpoint}${urlParams}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
  /**
     * @summary Retrieve
     * @description Get a specific user in a workplace
  
     * @param slug The slug of the workplace user
     * @returns {Promise<UsersGetResponse>} - The promise with the result
     */
  async get(slug) {
    if (slug === void 0) {
      throw new Error("The following parameter is required: slug, cannot be empty or blank");
    }
    let urlEndpoint = "/v3/workplace/users/{slug}";
    urlEndpoint = urlEndpoint.replace(
      "{slug}",
      encodeURIComponent(serializePath("simple", false, slug, void 0))
    );
    const finalUrl = `${this.baseUrl + urlEndpoint}`;
    const response = await this.httpClient.get(
      finalUrl,
      {},
      {
        ...this.getAuthorizationHeader()
      },
      true
    );
    const responseModel = response.data;
    return responseModel;
  }
};

// src/services/secrets/index.ts
var secrets_exports = {};

// src/services/projectMembers/index.ts
var projectMembers_exports = {};

// src/services/groups/index.ts
var groups_exports = {};

// src/services/projects/index.ts
var projects_exports = {};

// src/services/configLogs/index.ts
var configLogs_exports = {};

// src/services/environments/index.ts
var environments_exports = {};

// src/services/configs/index.ts
var configs_exports = {};

// src/services/serviceTokens/index.ts
var serviceTokens_exports = {};

// src/services/activityLogs/index.ts
var activityLogs_exports = {};

// src/services/workplace/index.ts
var workplace_exports = {};

// src/services/audit/index.ts
var audit_exports = {};

// src/services/dynamicSecrets/index.ts
var dynamicSecrets_exports = {};

// src/services/integrations/index.ts
var integrations_exports = {};

// src/services/syncs/index.ts
var syncs_exports = {};

// src/services/auth/index.ts
var auth_exports = {};

// src/services/workplaceRoles/index.ts
var workplaceRoles_exports = {};

// src/services/projectRoles/index.ts
var projectRoles_exports = {};

// src/services/invites/index.ts
var invites_exports = {};

// src/services/serviceAccounts/index.ts
var serviceAccounts_exports = {};

// src/services/users/index.ts
var users_exports = {};

// src/index.ts
var DopplerSDK = class {
  constructor({ accessToken = "" }) {
    this.projects = new ProjectsService(accessToken);
    this.secrets = new SecretsService(accessToken);
    this.configLogs = new ConfigLogsService(accessToken);
    this.environments = new EnvironmentsService(accessToken);
    this.configs = new ConfigsService(accessToken);
    this.activityLogs = new ActivityLogsService(accessToken);
    this.workplace = new WorkplaceService(accessToken);
    this.serviceTokens = new ServiceTokensService(accessToken);
    this.audit = new AuditService(accessToken);
    this.dynamicSecrets = new DynamicSecretsService(accessToken);
    this.auth = new AuthService(accessToken);
    this.integrations = new IntegrationsService(accessToken);
    this.syncs = new SyncsService(accessToken);
    this.workplaceRoles = new WorkplaceRolesService(accessToken);
    this.projectRoles = new ProjectRolesService(accessToken);
    this.projectMembers = new ProjectMembersService(accessToken);
    this.invites = new InvitesService(accessToken);
    this.serviceAccounts = new ServiceAccountsService(accessToken);
    this.groups = new GroupsService(accessToken);
    this.users = new UsersService(accessToken);
  }
  setBaseUrl(url) {
    this.projects.setBaseUrl(url);
    this.secrets.setBaseUrl(url);
    this.configLogs.setBaseUrl(url);
    this.environments.setBaseUrl(url);
    this.configs.setBaseUrl(url);
    this.activityLogs.setBaseUrl(url);
    this.workplace.setBaseUrl(url);
    this.serviceTokens.setBaseUrl(url);
    this.audit.setBaseUrl(url);
    this.dynamicSecrets.setBaseUrl(url);
    this.auth.setBaseUrl(url);
    this.integrations.setBaseUrl(url);
    this.syncs.setBaseUrl(url);
    this.workplaceRoles.setBaseUrl(url);
    this.projectRoles.setBaseUrl(url);
    this.projectMembers.setBaseUrl(url);
    this.invites.setBaseUrl(url);
    this.serviceAccounts.setBaseUrl(url);
    this.groups.setBaseUrl(url);
    this.users.setBaseUrl(url);
  }
  setAccessToken(accessToken) {
    this.projects.setAccessToken(accessToken);
    this.secrets.setAccessToken(accessToken);
    this.configLogs.setAccessToken(accessToken);
    this.environments.setAccessToken(accessToken);
    this.configs.setAccessToken(accessToken);
    this.activityLogs.setAccessToken(accessToken);
    this.workplace.setAccessToken(accessToken);
    this.serviceTokens.setAccessToken(accessToken);
    this.audit.setAccessToken(accessToken);
    this.dynamicSecrets.setAccessToken(accessToken);
    this.auth.setAccessToken(accessToken);
    this.integrations.setAccessToken(accessToken);
    this.syncs.setAccessToken(accessToken);
    this.workplaceRoles.setAccessToken(accessToken);
    this.projectRoles.setAccessToken(accessToken);
    this.projectMembers.setAccessToken(accessToken);
    this.invites.setAccessToken(accessToken);
    this.serviceAccounts.setAccessToken(accessToken);
    this.groups.setAccessToken(accessToken);
    this.users.setAccessToken(accessToken);
  }
};
var src_default = DopplerSDK;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ActivityLogsModels,
  AuditModels,
  AuthModels,
  ConfigLogsModels,
  ConfigsModels,
  DopplerSDK,
  DynamicSecretsModels,
  EnvironmentsModels,
  GroupsModels,
  IntegrationsModels,
  InvitesModels,
  ProjectMembersModels,
  ProjectRolesModels,
  ProjectsModels,
  SecretsModels,
  ServiceAccountsModels,
  ServiceTokensModels,
  SyncsModels,
  UsersModels,
  WorkplaceModels,
  WorkplaceRolesModels
});
